<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[人工智能的应用场景及企业应用AI的思考]]></title>
      <url>/2017/12/18/aiapp.html</url>
      <content type="html"><![CDATA[<blockquote>
<p>“我觉得不行！”；“我觉得可以！”</p>
</blockquote>
<p>这正是现在大家看待AI的两种态度。有人觉得现在去谈人工智能的商业化为时尚早，但也有人觉得人工智能已经在企业的许多业务场景中发挥至关重要的作用。无论如何，作为一个刷爆朋友圈，并且曝光度与日俱增的热门话题，许多企业都已经对AI“蠢蠢欲动”，甚至“先下手为强”了。</p>
<p>关于人工智能的商业化，麦肯锡全球研究院跨越14个行业、10个国家，对3073名企业高管进行了调查，并分析了160个案例，最终发布了《<a href="https://cdn.shup.cn/aiapp/mckinsey.pdf" rel="external nofollow noopener noreferrer" target="_blank">人工智能：下一个数字前沿？</a>》报告，其中，报告详细描述了5个应用案例，并对零售、电力、医疗3个行业应用进行了图解：</p>
<a id="more"></a>
<h1 id="零售：连接消费者，改善购物体验"><a href="#零售：连接消费者，改善购物体验" class="headerlink" title="零售：连接消费者，改善购物体验"></a>零售：连接消费者，改善购物体验</h1><img src="https://cdn.shup.cn/aiapp/retail.png" width="400" height="300">
<ul>
<li>图像识别、机器学习和自然语言处理等技术等发展使得智能服务机器人能够轻松与顾客打招呼、交流，可以预测订单，提供引导；</li>
<li>通过机器学习，可以根据消费者到个人资料进行个性化促销; 在顾客浏览店铺商品时，店内的信标（Beacon）也可以通过手机向他们发送优惠信息</li>
<li>基于深度学习的计算机视觉技术，可以识别购物者打包的商品; 加上传感器所获取的数据，AI使得自动结帐和付款成为可能</li>
<li>使用深度学习技术的无人机快递完成了零售业务链最后一英里的交付，能够实现避障并处理收货人不在的状况</li>
</ul>
<h1 id="电力：更少的电站，更智能的电网"><a href="#电力：更少的电站，更智能的电网" class="headerlink" title="电力：更少的电站，更智能的电网"></a>电力：更少的电站，更智能的电网</h1><img src="https://cdn.shup.cn/aiapp/retail.png" width="400" height="300">
<ul>
<li>通过传感器和机器学习系统，可以通过对风力条件的实时调整，最大限度地提高发电效率</li>
<li>通过机器学习可以预测电力的供需峰值，从而最大限度地利用间歇性可再生能源</li>
<li>智能电线与机器学习的结合，可以实现实时的电力调度，改善电网负载</li>
<li>无人机和小型机器人可以在不关停电路的情况下，检测和预测设备故障</li>
<li>机器可以替代人工自动记录数据并检查设备状态，从而减少对技术人员的需求数量，使他们可以花更多时间解决其它问题</li>
</ul>
<h1 id="医疗：更快的诊断，更好的治疗"><a href="#医疗：更快的诊断，更好的治疗" class="headerlink" title="医疗：更快的诊断，更好的治疗"></a>医疗：更快的诊断，更好的治疗</h1><img src="https://cdn.shup.cn/aiapp/health.png" width="400" height="300">
<ul>
<li>机器学习程序可以通过可穿戴设备远程分析患者的健康状况，并将数据与其医疗记录进行比较，提供健康建议并预警疾病风险</li>
<li>使用机器学习和其他相关的AI技术，设备可以进行自主诊断并帮患者做简单的体征指标检查，而无需人力辅助，从而减轻医生和护士的工作压力</li>
<li>根据患者的历史医疗数据和记录，基于AI的诊断工具可以更准确地诊断疾病</li>
<li>根据医疗和环境等因素，AI算法可以预测患者行为和疾病的概率，从而优化医院运营、排班计划和库存管理</li>
</ul>
<h1 id="制造：更智能、更灵活"><a href="#制造：更智能、更灵活" class="headerlink" title="制造：更智能、更灵活"></a>制造：更智能、更灵活</h1><ul>
<li>对于工程和研发人员而言，人工智能工具的使用意味着更快的周转时间和更少的迭代次数，效率得到大大提升</li>
<li>获取全球各地的供应商信息，降低采购过程中的成本，更好地管理供应链，使得收益最大化</li>
<li>项目经理可以使用基于人工智能的高级分析，从而提高审查流程的有效性</li>
<li>AI可以帮助企业重新审视制造流程和生产线，并针对性地进行优化和调整，从而以降低成本、减少资源浪费，加快企业上市速度</li>
<li>制造商可以利用AI技术为客户提供更优质的售后服务</li>
<li>工作人员与工厂的生产线必须更好地进行协同作业，从而挖掘AI的全部潜力，实现其中的价值</li>
</ul>
<h1 id="教育：不断优化教学形式和效果"><a href="#教育：不断优化教学形式和效果" class="headerlink" title="教育：不断优化教学形式和效果"></a>教育：不断优化教学形式和效果</h1><ul>
<li>解决教育资源分布不均的问题，并根据市场需求帮助政府机构不断优化教育制度，提高人才与市场的匹配度</li>
<li>为学生提供更有针对性的教学计划，改善学习成果，并帮助学校不断改进课程组合，提高毕业生就业率</li>
<li>通过自适应学习系统，在合适的时间以最佳方式向每个学生提供适当的内容，打造个性化教学</li>
<li>自然语言、计算机视觉和深度学习可以帮助教师回答学生的常规问题或担任教学助教，使得教师可以把更多的时间花在更具价值的教学环节中。</li>
</ul>
<p>下图展示了人工智能在各个行业的渗透率：<br><img src="https://cdn.shup.cn/aiapp/aidemand.png" width="400" height="300"></p>
<p>也可以看到，已经采用了AI策略的公司的利润率得到了显著提升（尤其是金融和医疗行业）：<br><img src="https://cdn.shup.cn/aiapp/profit.png" width="400" height="300"></p>
<p>正因如此，越来越多的企业CEO开始重视人工智能技术的影响，并亲自主导相关项目的开展。据IBM商业价值研究院在今年6月份发布的一项调查结果显示，73%受调查的企业CEO认为，人工智能将为企业的未来起到重要的作用，其中，50%的CEO计划在2019年前采用相关技术。</p>
<h1 id="企业应用AI技术的10个关键思考点"><a href="#企业应用AI技术的10个关键思考点" class="headerlink" title="企业应用AI技术的10个关键思考点"></a>企业应用AI技术的10个关键思考点</h1><p>当然，还未采用人工智能技术的企业也不必感到焦虑和恐慌。企业未来战略如何布局，如何更好地运用这些技术，在运用过程中如何推进，这些都成为目前摆在企业面前的问题。基于麦肯锡的报告，我们总结了企业在应用AI技术的过程中的10个关键思考点。</p>
<ol>
<li><p>不要听信所有炒作：其实并非每个企业都已在使用人工智能。虽然人们对AI的投资正在升温，但企业对人工智能技术的采用仍然有些滞后。虽然AI的总投资额（包括内部和外部的）在2016年达到了260亿美元到390亿美元，其中外部投资是2013年的三倍。然而，AI的应用仍处于初步阶段，在麦肯锡的调查对象中，只有20%的受访者在一个或一个以上的业务或是核心业务中大规模使用AI技术。（调查涵盖了五个范畴下的AI技术系统：机器人和自动驾驶汽车、计算机视觉、语言、虚拟代理和机器学习）</p>
<img src="https://cdn.shup.cn/aiapp/invest.png" width="400" height="300">
</li>
<li><p>要相信AI可以提升公司的营收和利润这类“炒作”。根据麦肯锡的调查，AI早期采用者（即大规模使用AI或在核心业务采用AI的公司）中有30%的用户表示他们已经实现了收入的增长，利用AI获得了更高的市场份额，或提升了产品和服务能力。此外，AI早期采用者中预计自己公司的利润率增长到比同行高出5%的人相较其他人要多3.5倍。证据表明，人工智能已经能够直接提高企业利润，使得AI投资的投资回报率（ROI）与其相关数字技术范畴的投资回报率相同，如大数据和高级分析。</p>
</li>
<li><p>没有领导的支持，你的AI转型计划可能会失败。成功的人工智能采用者往往拥有领导对新技术最强有力的支持。调查反馈显示，已经成功大规模部署AI技术的调查对象得到公司管理层的支持率几乎是那些没有采用任何AI技术支持的公司的2倍。此外，除了从其公司CEO和IT部门主管那里获得了强有力的支持，他们还获得了来自全部管理层高管和董事会的支持。</p>
</li>
<li><p>不要一个人独立专研AI，你还需要合作伙伴的才干和能力。经历数十年的“寒冬”，人工智能领域最近才开始加速其创新的步伐，而具备专业技术和能力人才也出现了稀缺的情况。即便是亚马逊和谷歌这样的大型数字原生代公司也开始转向通过外部市场的企业和人才，以增强其自身的AI技能。例如Google对DeepMind公司的收购，正是因为DeepMind能够运用其机器学习能力帮助Google提升搜索优化等核心业务。另外，据调查显示，AI的早期使用者主要是通过购买外部适用的技术解决方案来实现，只有少数的调查对象完全是由公司内部人才开发和实施人工智能解决方案。</p>
</li>
<li><p>避免让技术团队独立进行人工智能项目和计划。在IT、数字或创新领域分别任命不同的部门主管，划分人工智能的管理职责，可能会导致“拿着锤子找钉子”的结果出现，为确保企业能够把关注点放在最有价值的案例上，人工智能项目应该由业务和技术部门主管共同评估和领导。</p>
</li>
<li><p>采用投资组合的方式加速公司的AI历程。AI工具如今的应用范围已相当广泛，能够解决具体商业问题，例如用于预测性维护等等。各组织机构可以考虑在融合AI技术时采用一种基于投资组合的方法。</p>
</li>
<li><p>机器学习是一种强大的工具，但它并非适用于所有事物。机器学习及其最为突出的子领域深度学习已经吸引了众多媒体的关注，并获得了占据2016年所有外部投资近60%份额的融资。<br>但即便如此，机器学习也只是众多能够解决企业问题的人工智能技术中的一项。并不存在什么放之四海而皆可用的人工智能解决方案。例如，为实现客户服务中心效率的提高所采用的AI技术可能与用于识别信用卡诈骗风险所采用的技术迥然不同。因此，在一个企业的数字与AI技术应用历程的特定阶段，寻找合适的工具解决每一个增值的业务问题才是至关重要的。<br>不同的人工智能技术之间是有交集的，然而分界线并不是很明确：</p>
<img src="https://cdn.shup.cn/aiapp/ml.png" width="400" height="300">
</li>
<li><p>数字化能力应该优先于AI。调查发现，在AI应用方面领先的行业，如高科技、电信和汽车等，也是数字化程度最高的行业。同样，所有早期应用AI技术的企业都已在包括云基础架构和大数据的数字化能力方面进行了投资。事实上，没有数字化转型经验的企业似乎很难轻易地跳跃到AI领域。通过一连串的统计分析，我们发现在数字化方面经验较多的企业在融合AI技术时创造出利润的可能性相比其他公司要高出50%。<br>数字化程度更高的行业融合人工智能技术的速率更高：</p>
<img src="https://cdn.shup.cn/aiapp/adoption.png" width="400" height="300">
</li>
<li><p>要大胆勇敢。在一项关于数字化颠覆（digital disruption）的独立研究中，我们发现要扭转数字化颠覆的“魔咒”，采取更“激进”的数字化战略是最重要的因素。采用这样策略的企业将从根本上调整其业务的投资组合，开发新的商业模式，以构建一个比其数字化前更加强大的增长途径。截至目前，这一因素似乎也适用于AI：AI的早期应用者中恰好采取积极、“激进”策略的企业较其他企业拥有更好的利润前景。<br>AI转型与数字化转型所需的相似的条件和要素：</p>
<img src="https://cdn.shup.cn/aiapp/elements.png" width="400" height="300">
</li>
<li><p>人与流程是最大的挑战。多数情况下，对管理层而言，将AI纳入到企业的流程和决策过程的挑战其实远远超过了实施AI的技术性挑战。作为领导者，需要决定哪些任务由机器处理，哪些任务由人类执行，而且无论是新任务还是传统任务，实施能够让员工持续学习的程序将是至关重要的。随着AI技术与先进的可视化技术、协作和设计思维的继续融合，企业未来需要将主要关注点从流程效率转向决策管理的有效性，而这将进一步要求领导者打造一个持续改进和学习的文化氛围。</p>
</li>
</ol>
<p>毫无疑问，AI就是下一个数字前沿。尽管一些公司仍未从之前的数字化颠覆中“缓”过来，但新的数字化颠覆正在成型。不过目前我们仍在早期阶段，还有时间将AI打造成自己的竞争优势。不妨先从这10条建议入手，开始规划自己的人工智能战略吧。</p>
]]></content>
      
        
        <tags>
            
            <tag> 人工智能 </tag>
            
            <tag> 应用 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用Github的10个实用技巧]]></title>
      <url>/2017/12/12/github.html</url>
      <content type="html"><![CDATA[<p>GitHub是一个面向开源及私有软件项目的托管平台，因为只支持<code>git</code>作为唯一的版本库格式进行托管，故名GitHub。除了代码仓库托管及基本的 Web管理界面以外，还提供了订阅、讨论、文本渲染、在线文件编辑、协作图谱（报表）、代码片段分享（Gist）等功能。目前，注册用户已经超过350万，托管版本数量也是非常之多，其中不乏知名开源项目 Ruby、jQuery、Python等。使用Github已经有一段时间了，下面总结一下Github的10个实用技巧：</p>
<a id="more"></a>
<h1 id="编辑代码"><a href="#编辑代码" class="headerlink" title="编辑代码"></a>编辑代码</h1><p>先从地球人都知道的代码编辑开始：在GitHub上，点进任意一个文件（任何代码仓库repository的任何文件），右上角有一个小铅笔的图标。点击它，GitHub将fork到你的repo(在你的repo中建立一个新分支)，然后就可以在你的repo中任意编辑文件。完成后，点击下方的<strong>Propose file change</strong>，申请将修改合并到原项目中(即pull request)，这样原项目的作者就可以将你修改的东西合并到原项目的主分支上去，这样就为开源项目贡献了代码，开源项目就会在大家共同的努力下不断壮大和完善。<br><img src="https://cdn.shup.cn/github/edit.png" width="400" height="300"></p>
<h1 id="粘贴图像"><a href="#粘贴图像" class="headerlink" title="粘贴图像"></a>粘贴图像</h1><p>评论区和issue中不仅限于文字，还可以直接从剪贴板粘贴图片(网上的图片，本地图片不可以)。右键粘贴时，会看到它被上传到云端(<code>user-images.githubusercontent.com</code>)，并自动使用Markdown语法插入文中。</p>
<h1 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h1><p>如果想写一个代码块，可以从三个反引号开始 - 就像使用Markdown一样简单，GitHub将自动检测你使用的编程语言。但是，如果发布的是Vue，Typescript或JSX之类的代码片段，最好可以明确指定该代码语言以获得更准确的高亮显示，比如：</p>
<p>在反引号后加入语言名称：<br><img src="https://cdn.shup.cn/github/jsxwrite.png" width="400" height="300"><br>预览中可以看到代码高亮正确渲染：<br><img src="https://cdn.shup.cn/github/jsxrendered.png" width="400" height="300"></p>
<p><strong>备注</strong>：此方法同样适用代码片段分享(Gist)。</p>
<p>这是所有Github自动支持代码高亮的<a href="https://github.com/github/linguist/blob/fc1404985abb95d5bc33a0eba518724f1c3c252e/vendor/README.md" rel="external nofollow noopener noreferrer" target="_blank">语言列表</a>，基本上是只有不知道的，没有不支持的。</p>
<h1 id="在pull-request中用魔术词结束issue"><a href="#在pull-request中用魔术词结束issue" class="headerlink" title="在pull request中用魔术词结束issue"></a>在pull request中用魔术词结束issue</h1><p>假设创建一个PR来解决问题＃123，可以把文字“Closes＃123”放在PR的描述中（或者在PR评论中的任何地方），合并后Github自动关闭这个issue。</p>
<p>这里是官方的<a href="https://help.github.com/articles/closing-issues-using-keywords/" rel="external nofollow noopener noreferrer" target="_blank">详细说明</a>。</p>
<h1 id="链接到评论"><a href="#链接到评论" class="headerlink" title="链接到评论"></a>链接到评论</h1><p>是否想过要链接到一个特定的评论，但不知如何实现？只需要点击用户名旁边的时间就可以在浏览器地址栏里得到特定评论的地址。<br><img src="https://cdn.shup.cn/github/commentlink.png" width="400" height="300"></p>
<h1 id="链接到代码"><a href="#链接到代码" class="headerlink" title="链接到代码"></a>链接到代码</h1><p>在查看文件时，点击代码旁边的行号，看到了吗？浏览器里的网址已更新为行号！如果按住Shift键选中到另一个行，则URL将再次更新，这样就突出显示了多行代码。</p>
<p>分享浏览器的链接就可以精准定位到这段代码。但是！现在是指向当前的分支，如果该文件改变分支了怎么办？点击<code>Copy Permalink</code>就可以获得永久固定链接地址。<br><img src="https://cdn.shup.cn/github/codelink.png" width="400" height="300"></p>
<h1 id="在issue中创建列表"><a href="#在issue中创建列表" class="headerlink" title="在issue中创建列表"></a>在issue中创建列表</h1><p>看看issue中的复选框列表:<br><img src="https://cdn.shup.cn/github/checklist.png" width="400" height="300"><br>用列表方式看issue，更简洁明了，用Markdown就可以创造这样的列表：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">- [ ]<span class="built_in"> Screen </span>width (integer)</span><br><span class="line">- [x]<span class="built_in"> Service </span>worker support</span><br><span class="line">- [x] Fetch support</span><br><span class="line">- [ ] CSS flexbox support</span><br><span class="line">- [ ] Custom elements</span><br></pre></td></tr></table></figure>
<p>而且是可以勾选的，不是死的。更神奇的是在主页上还可以显示<strong>进度条</strong>：<br><img src="https://cdn.shup.cn/github/checkstatus.png" width="400" height="300"></p>
<h1 id="项目看板"><a href="#项目看板" class="headerlink" title="项目看板"></a>项目看板</h1><p>管理大项目用trello很方便，可以让你在一个便利的位置，一目了然地掌握正在处理的所有事情。<br><img src="https://cdn.shup.cn/github/trello.png" width="400" height="300"><br>GitHub也不落后，也有类似trello的项目管理界面。不过UI没有trello那么漂亮。<br><img src="https://cdn.shup.cn/github/project.png" width="400" height="300"><br>在GitHub中管理任务的强大之处在于它可以与repo其余部分集成在一起 - 所以可以把repo现有的issue添加到看板上。可以点击右上角的<strong>Add cards</strong>，找到要添加的内容。在这里，特殊的<a href="https://help.github.com/articles/searching-issues-and-pull-requests/" rel="external nofollow noopener noreferrer" target="_blank">搜索语法</a>就可以派上用场了，例如，类型<code>is:pr</code> <code>is:open</code>，然后可以把所有开放的PR拖动到面板上，或者<code>label:bug</code>等。<br><img src="https://cdn.shup.cn/github/addcards.png" width="400" height="300"><br>也可以将现有的note转换成issue。<br><img src="https://cdn.shup.cn/github/note2issue.png" width="400" height="300"><br>Github中定义任务与实现该任务的代码放在同一repo中有很大的好处，同步且可追溯！这意味着从现在开始，你可以在一段代码上用<a href="http://blog.csdn.net/hudashi/article/details/7668810" rel="external nofollow noopener noreferrer" target="_blank">Git Blame</a>，并找到产生此段代码的任务背后的原始依据，而不需要像Trello一样要去别的地方去溯源。</p>
<h1 id="GitHub-Wiki"><a href="#GitHub-Wiki" class="headerlink" title="GitHub Wiki"></a>GitHub Wiki</h1><p>目前在 GitHub 上发布的项目，一般使用 Markdown 来编写项目文档和 <code>README.md</code> 等。Markdown 一般情况下能够满足的文档编写需求，如果使用得当的话，效果也非常棒。不过当项目文档比较长的时候，阅读体验可能就不是那么理想了。如果已经超过了一个单一的<code>README.md</code>文件，希望有像<a href="https://www.gitbook.com/explore?lang=zh" rel="external nofollow noopener noreferrer" target="_blank">Gitbook</a>一样(比如《<a href="http://docker_practice.gitee.io/" rel="external nofollow noopener noreferrer" target="_blank">Docker — 从入门到实践</a>》)、更详细的用户指南或说明文档，那么应该选择Gwiki。GitHub 每一个项目都有一个独立完整的 Wiki 页面，可以用它来实现项目信息管理，为项目提供更加完善的文档。可以把 Wiki作为项目文档的一个重要组成部分，将冗长、具体的文档整理成 Wiki，将精简的、概述性的内容，放到项目中或是 <code>README.md</code>里。</p>
<p>完美的Gwiki页面：可以参观一下<a href="https://github.com/onevcat/Kingfisher/wiki" rel="external nofollow noopener noreferrer" target="_blank">Kingfisher的Gwiki</a>。</p>
<p>Gwiki的具体编辑方法可以参考这篇文章《<a href="http://www.jianshu.com/p/c187fd088b71" rel="external nofollow noopener noreferrer" target="_blank">GitHub Wiki 页面的添加和设置</a>》。</p>
<h1 id="用GitHub创建Hexo、Jekyll"><a href="#用GitHub创建Hexo、Jekyll" class="headerlink" title="用GitHub创建Hexo、Jekyll"></a>用GitHub创建Hexo、Jekyll</h1><p>你可能已经知道了可以使用GitHub页面来托管一个静态网站。把本地的页面，可以是Hexo、Jekyll等程序，也可以是自己的静态网页，通过Git部署到你GitHub的repo里。这方面的文章网上很多，自行搜索。</p>
<h1 id="GitHub扩展小工具"><a href="#GitHub扩展小工具" class="headerlink" title="GitHub扩展小工具"></a>GitHub扩展小工具</h1><p>最后再赠送一个实用小工具，使用Chrome浏览器可以添加<a href="https://chrome.google.com/webstore/detail/octotree/bkhaagjahfmjljalopjnoealnfndnagc?hl=zh-CN" rel="external nofollow noopener noreferrer" target="_blank">Octotree</a>插件，它提供了一个左侧的面板，可以查看的repo的树状结构图。所有目录里面的文件都会一次性预读取，不用像传统方式一层一层地点进去，就像在本地用文件资源管理器一样方便。<br><img src="https://cdn.shup.cn/github/Octotree.png" width="400" height="300"></p>
]]></content>
      
        
        <tags>
            
            <tag> Github </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[基于Python的下载神器You-Get]]></title>
      <url>/2017/12/12/youget.html</url>
      <content type="html"><![CDATA[<p>You-Get(<a href="https://you-get.org/" rel="external nofollow noopener noreferrer" target="_blank">官网</a>)乃一小小哒命令行程序，通过极其便利的方式来下载网络上的媒体信息（视频，音频，图像）等。只需要在命令行输入<code>you-get+&#39;链接&#39;</code>，程序就可以自动解析文件地址，并自动开始下载并保存。比如下面这个例子：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">you-get <span class="string">http:</span><span class="comment">//www.fsf.org/blogs/rms/20140407-geneva-tedx-talk-free-software-free-society</span></span><br><span class="line"><span class="string">Site:</span>       fsf.org</span><br><span class="line"><span class="string">Title:</span>      TEDxGE2014_Stallman05_LQ</span><br><span class="line"><span class="string">Type:</span>       WebM video (video/webm)</span><br><span class="line"><span class="string">Size:</span>       <span class="number">27.12</span> MiB (<span class="number">28435804</span> Bytes)</span><br><span class="line"></span><br><span class="line">Downloading TEDxGE2014_Stallman05_LQ.webm ...</span><br><span class="line"><span class="number">100.0</span>% ( <span class="number">27.1</span><span class="regexp">/27.1 MB) ├████████████████████████████████████████┤[1/</span><span class="number">1</span>]   <span class="number">12</span> MB/s</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="为什么要用You-get"><a href="#为什么要用You-get" class="headerlink" title="为什么要用You-get"></a>为什么要用You-get</h1><ul>
<li>发现喜欢的媒体文件，然而网站却禁止下载</li>
<li>摆脱闭源技术或JavaScript的束缚，并禁止诸如Flash之类的运行</li>
<li>拥护黑客精神和自由软件</li>
</ul>
<h1 id="You-Get的功能"><a href="#You-Get的功能" class="headerlink" title="You-Get的功能:"></a>You-Get的功能:</h1><ul>
<li>下载流行网站的音视频，例如UTube, Youku等。(查看<a href="https://you-get.org/#supported-sites" rel="external nofollow noopener noreferrer" target="_blank">完整支持列表</a>)</li>
<li>下载后可在习惯的播放器中观看在线视频，脱离浏览器与广告</li>
<li>下载喜欢的图片</li>
<li>下载任何非HTML内容，例如二进制文件</li>
</ul>
<p>心动吗？下面开始学习如何安装和使用。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>以下为必要依赖，需要单独预装，除非你已经装好或者知道如何区分。</p>
<ul>
<li><strong><a href="https://www.python.org/downloads/" rel="external nofollow noopener noreferrer" target="_blank">Python 3</a></strong></li>
<li><strong><a href="https://www.ffmpeg.org/" rel="external nofollow noopener noreferrer" target="_blank">FFmpeg</a></strong> (强烈推荐) or <a href="https://libav.org/" rel="external nofollow noopener noreferrer" target="_blank">Libav</a></li>
<li>(可选) <a href="https://rtmpdump.mplayerhq.hu/" rel="external nofollow noopener noreferrer" target="_blank">RTMPDump</a></li>
</ul>
<h2 id="选项-1-通过pip安装"><a href="#选项-1-通过pip安装" class="headerlink" title="选项 1: 通过pip安装"></a>选项 1: 通过pip安装</h2><p><code>you-get</code>官方版本通过<a href="https://pypi.python.org/pypi/you-get" rel="external nofollow noopener noreferrer" target="_blank">PyPI</a>分发, 可从PyPI镜像中通过<code>pip</code>包管理器安装. 必须要使用Python3版本的 <code>pip</code>:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">pip3 <span class="keyword">install</span> you-<span class="keyword">get</span></span><br></pre></td></tr></table></figure>
<h2 id="选项-2-使用预装包-仅供Windows"><a href="#选项-2-使用预装包-仅供Windows" class="headerlink" title="选项 2: 使用预装包(仅供Windows)"></a>选项 2: 使用预装包(仅供Windows)</h2><p><code>exe</code> (单独文件) 或 <code>7z</code> (包括所有依赖) 可从<a href="https://github.com/soimort/you-get/releases/latest" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/soimort/you-get/releases/latest</a> 下载。</p>
<h2 id="选项-3-于GitHub下载"><a href="#选项-3-于GitHub下载" class="headerlink" title="选项 3: 于GitHub下载"></a>选项 3: 于GitHub下载</h2><p>您可选择<a href="https://github.com/soimort/you-get/archive/master.zip" rel="external nofollow noopener noreferrer" target="_blank">稳定版</a> (与PyPI最新版等同) 或 <a href="https://github.com/soimort/you-get/archive/develop.zip" rel="external nofollow noopener noreferrer" target="_blank">开发版</a> (更多的新但不稳定功能)的<code>you-get</code>. 解压并将含有<code>you-get</code>的目录加入<code>PATH</code>.</p>
<p>或者在指定路径运行，以安装<code>you-get</code> 于指定路径。：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">make <span class="keyword">install</span></span><br></pre></td></tr></table></figure>
<h2 id="选项-4-Git-clone-推荐"><a href="#选项-4-Git-clone-推荐" class="headerlink" title="选项 4: Git clone(推荐)"></a>选项 4: Git clone(推荐)</h2><p>这是最简单、最常用的办法：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">git</span>://github.com/soimort/you-get.git</span><br></pre></td></tr></table></figure>
<p>将目录加入 <code>PATH</code>, 或在指定路径运行 <code>make install</code> 以安装<code>you-get</code> 于指定路径。</p>
<h1 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h1><h2 id="下载视频"><a href="#下载视频" class="headerlink" title="下载视频"></a>下载视频</h2><p>发现喜欢的视频，先用<code>you-get -info</code>或<code>you-get -i</code>，查看所有可下载的画质与格式，例如：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">you-get</span> <span class="bullet">-i</span> <span class="string">'http://v.youku.com/v_show/id_XMzIyMzk0MjYwMA==.html?f=51386181'</span></span><br><span class="line"><span class="attr">site:</span>                <span class="string">Youku</span></span><br><span class="line"><span class="attr">title:</span>               <span class="string">Me</span> <span class="string">at</span> <span class="string">the</span> <span class="string">zoo</span></span><br><span class="line"><span class="attr">streams:</span>             <span class="comment"># Available quality and codecs</span></span><br><span class="line">    <span class="string">[</span> <span class="string">DEFAULT</span> <span class="string">]</span> <span class="string">_________________________________</span></span><br><span class="line"><span class="attr">    - itag:</span>          <span class="number">43</span></span><br><span class="line"><span class="attr">      container:</span>     <span class="string">webm</span></span><br><span class="line"><span class="attr">      quality:</span>       <span class="string">medium</span></span><br><span class="line"><span class="attr">      size:</span>          <span class="number">0.5</span> <span class="string">MiB</span> <span class="string">(564215</span> <span class="string">bytes)</span></span><br><span class="line">    <span class="comment"># download-with: you-get --itag=43 [URL]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">    - itag:</span>          <span class="number">18</span></span><br><span class="line"><span class="attr">      container:</span>     <span class="string">mp4</span></span><br><span class="line"><span class="attr">      quality:</span>       <span class="string">medium</span></span><br><span class="line">    <span class="comment"># download-with: you-get --itag=18 [URL]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">    - itag:</span>          <span class="number">5</span></span><br><span class="line"><span class="attr">      container:</span>     <span class="string">flv</span></span><br><span class="line"><span class="attr">      quality:</span>       <span class="string">small</span></span><br><span class="line">    <span class="comment"># download-with: you-get --itag=5 [URL]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">    - itag:</span>          <span class="number">36</span></span><br><span class="line"><span class="attr">      container:</span>     <span class="number">3</span><span class="string">gp</span></span><br><span class="line"><span class="attr">      quality:</span>       <span class="string">small</span></span><br><span class="line">    <span class="comment"># download-with: you-get --itag=36 [URL]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">    - itag:</span>          <span class="number">17</span></span><br><span class="line"><span class="attr">      container:</span>     <span class="number">3</span><span class="string">gp</span></span><br><span class="line"><span class="attr">      quality:</span>       <span class="string">small</span></span><br><span class="line">    <span class="comment"># download-with: you-get --itag=17 [URL]</span></span><br></pre></td></tr></table></figure>
<p>标有<code>DEFAULT</code> 为默认画质。如认同，可通过<code>you-get+&#39;链接&#39;</code>下载：</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">you-<span class="built_in">get</span> <span class="string">'http://v.youku.com/v_show/id_XMzIyMzk0MjYwMA==.html?f=51386181'</span></span><br><span class="line">site:                Youku</span><br><span class="line">title:               Me <span class="keyword">at</span> <span class="keyword">the</span> zoo</span><br><span class="line">stream:</span><br><span class="line">    - itag:          <span class="number">43</span></span><br><span class="line">      container:     webm</span><br><span class="line">      quality:       medium</span><br><span class="line">      size:          <span class="number">0.5</span> MiB (<span class="number">564215</span> <span class="keyword">bytes</span>)</span><br><span class="line">    <span class="comment"># download-with: you-get --itag=43 [URL]</span></span><br><span class="line"></span><br><span class="line">Downloading zoo.webm ...</span><br><span class="line"><span class="number">100.0</span>% (  <span class="number">0.5</span>/<span class="number">0.5</span>  MB) ├████████████████████████████████████████┤[<span class="number">1</span>/<span class="number">1</span>]    <span class="number">7</span> MB/s</span><br><span class="line"></span><br><span class="line">Saving Me <span class="keyword">at</span> <span class="keyword">the</span> zoo.en.srt ...Done.</span><br></pre></td></tr></table></figure>
<p>(如果视频带有字幕，将被一同下载，以SubRip格式保存。)</p>
<p>如果希望下载其他格式(mp4)，请使用其他选项命令<code>--itag=</code>，例如：</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">you-get --itag=<span class="number">18</span> 'http://v.youku.com/v_show/id_XMzIyMzk0MjYwMA==.html?f=<span class="number">51386181</span>'</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong></p>
<ul>
<li>目前，格式选择没有大规模铺开；默认选项为最高画质</li>
<li>如要下载分块视频(例如，类似Youku), 以及UTube的1080p或更高分辨率，则<code>ffmpeg</code>为必要依赖</li>
<li>如不希望<code>you-get</code>合并视频，使用<code>--no-merge</code>/<code>-n</code></li>
</ul>
<h2 id="下载其他内容"><a href="#下载其他内容" class="headerlink" title="下载其他内容"></a>下载其他内容</h2><p>对于任意一个链接地址，可以直接使用，例如：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">you-get <span class="string">https:</span><span class="comment">//stallman.org/rms.jpg</span></span><br><span class="line"><span class="string">Site:</span>       stallman.org</span><br><span class="line"><span class="string">Title:</span>      rms</span><br><span class="line"><span class="string">Type:</span>       JPEG Image (image/jpeg)</span><br><span class="line"><span class="string">Size:</span>       <span class="number">0.06</span> MiB (<span class="number">66482</span> Bytes)</span><br><span class="line"></span><br><span class="line">Downloading rms.jpg ...</span><br><span class="line"><span class="number">100.0</span>% (  <span class="number">0.1</span><span class="regexp">/0.1  MB) ├████████████████████████████████████████┤[1/</span><span class="number">1</span>]  <span class="number">127</span> kB/s</span><br></pre></td></tr></table></figure>
<p>或者, <code>you-get</code>将自动检查网页，下载一切有可能感兴趣的内容：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">you-get <span class="string">http:</span><span class="comment">//kopasas.tumblr.com/post/69361932517</span></span><br><span class="line"><span class="string">Site:</span>       Tumblr.com</span><br><span class="line"><span class="string">Title:</span>      kopasas</span><br><span class="line"><span class="string">Type:</span>       Unknown type (None)</span><br><span class="line"><span class="string">Size:</span>       <span class="number">0.51</span> MiB (<span class="number">536583</span> Bytes)</span><br><span class="line"></span><br><span class="line"><span class="string">Site:</span>       Tumblr.com</span><br><span class="line"><span class="string">Title:</span>      tumblr_mxhg13jx4n1sftq6do1_1280</span><br><span class="line"><span class="string">Type:</span>       Portable Network Graphics (image/png)</span><br><span class="line"><span class="string">Size:</span>       <span class="number">0.51</span> MiB (<span class="number">536583</span> Bytes)</span><br><span class="line"></span><br><span class="line">Downloading tumblr_mxhg13jx4n1sftq6do1_1280.png ...</span><br><span class="line"><span class="number">100.0</span>% (  <span class="number">0.5</span><span class="regexp">/0.5  MB) ├████████████████████████████████████████┤[1/</span><span class="number">1</span>]   <span class="number">22</span> MB/s</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong></p>
<ul>
<li>此功能尚在测试阶段。对于类似Tumblr和Blogger的大图有效，但是暂时不适用所有网站。</li>
</ul>
<h2 id="暂停与恢复下载"><a href="#暂停与恢复下载" class="headerlink" title="暂停与恢复下载"></a>暂停与恢复下载</h2><p>可以使用Ctrl+C 暂停下载。</p>
<p>临时的<code>.download</code>文件将保存于输出目录。下次使用<code>you-get</code>传入相同参数时，下载将从上次断点继续开始。如果下载已经完成 (临时的<code>.download</code> 扩展名消失), <code>you-get</code>将忽略下载。</p>
<p>用<code>--force</code>/<code>-f</code>强行重新下载. (<strong>注意:</strong> 将覆盖同名文件或临时文件!)</p>
<h2 id="设置输出文件名或路径"><a href="#设置输出文件名或路径" class="headerlink" title="设置输出文件名或路径"></a>设置输出文件名或路径</h2><p>使用<code>--output-dir</code>/<code>-o</code> 设定路径, <code>--output-filename</code>/<code>-O</code> 设定输出文件名:</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">you-get -o ~/Videos -O zoo<span class="selector-class">.webm</span> <span class="string">'http://v.youku.com/v_show/id_XMzIyMzk0MjYwMA==.html?f=51386181'</span></span><br></pre></td></tr></table></figure>
<p><strong>提示:</strong></p>
<ul>
<li>如果原视频标题含有与系统不兼容字符，十分有效</li>
<li>也可以帮助使用脚本批量下载到指定目录和文件名</li>
</ul>
<h2 id="代理设置"><a href="#代理设置" class="headerlink" title="代理设置"></a>代理设置</h2><p>使用 <code>--http-proxy</code>/<code>-x</code>为<code>you-get</code>设置HTTP代理:</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">you-get -x <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">8087</span> 'http://v.youku.com/v_show/id_XMzIyMzk0MjYwMA==.html?f=<span class="number">51386181</span>'</span><br></pre></td></tr></table></figure>
<p>使用<code>--no-proxy</code>强行关闭代理。如需科学上网，可以参考另外一篇文章：《<a href="/2017/11/23/ss.html">利用免费的Google Cloud来部署科学上网神器SS</a>》</p>
<h2 id="观看视频"><a href="#观看视频" class="headerlink" title="观看视频"></a>观看视频</h2><p>使用 <code>--player</code>/<code>-p</code> 将视频feed给播放器, 例如 <code>mplayer</code> 或者 <code>vlc</code>，这里不是下载，直接在线看:</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">you-get -<span class="selector-tag">p</span> vlc <span class="string">'http://v.youku.com/v_show/id_XMzIyMzk0MjYwMA==.html?f=51386181'</span></span><br></pre></td></tr></table></figure>
<p>或者在浏览器中观看而不希望看到广告或评论区:</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">you-get -<span class="selector-tag">p</span> chromium <span class="string">'http://v.youku.com/v_show/id_XMzIyMzk0MjYwMA==.html?f=51386181'</span></span><br></pre></td></tr></table></figure>
<p><strong>提示:</strong></p>
<ul>
<li>可以使用 <code>-p</code> 开启下载工具,例如：<br><code>you-get -p uget-gtk &#39;http://v.youku.com/v_show/id_XMzIyMzk0MjYwMA==.html?f=51386181&#39;</code></li>
</ul>
<blockquote>
<p><strong><em>如果你使用本软件进行盗版行为，或者非法行径，作者不为你负责。</em></strong><br><strong><em>这里仅提供代码, 如何使用请自行斟酌。</em></strong></p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> You-Get </tag>
            
            <tag> Python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[非技术人员的机器学习入门指南]]></title>
      <url>/2017/12/04/machinelearning.html</url>
      <content type="html"><![CDATA[<p>人工智能是当前最热门的话题之一，仿佛一夜之间传遍大街小巷。经常能听到有理想、有抱负的开发者说想学习人工智能，又或是企业的管理者说想在产品或服务中实现人工智能。机器学习作为成就人工智能最重要的一种分支类型，如今，科技巨头们无不在对其加紧布局，迎接市场爆发。虽然炙手可热，但是很多时候，人们只有模糊的概念，并不了解什么才是机器学习。<br><a id="more"></a></p>
<h1 id="世界末日？"><a href="#世界末日？" class="headerlink" title="世界末日？"></a>世界末日？</h1><p>首先，我们听说机器学习正在取代蓝领的工作：</p>
<blockquote>
<p><a href="http://baijiahao.baidu.com/s?id=1576405571551276066" rel="external nofollow noopener noreferrer" target="_blank"><em>人工智能时代，蓝领的未来在哪里？</em></a></p>
</blockquote>
<p>然后，我们发现白领的工作也不安全：</p>
<blockquote>
<p><a href="https://www.leiphone.com/news/201706/bjdicjg5mfEF7omK.html" rel="external nofollow noopener noreferrer" target="_blank"><em>Watson治疗癌症准确率超90%，医生该高兴还是难过？</em></a></p>
</blockquote>
<p>抛开工作不看，发现机器之间居然可以聊天：</p>
<blockquote>
<p><a href="http://tech.qq.com/a/20170621/021996.htm" rel="external nofollow noopener noreferrer" target="_blank"><em>FB意外发现：聊天机器人开始自创语言了！</em></a></p>
</blockquote>
<p>甚至，机器已经开始独孤求败了：</p>
<blockquote>
<p><a href="http://www.cnbeta.com/articles/tech/662311.htm" rel="external nofollow noopener noreferrer" target="_blank"><em>AlphaGo Zero证明 机器无需帮助即可成为超人</em></a></p>
</blockquote>
<p>机器学习在很多不同的背景下被讨论着，所以很难把握它究竟是什么。通过搜索你可能获得一堆抽象的理论解释、或者是拼词游戏、又或是一堆数学公式和代码。</p>
<h1 id="开始学习"><a href="#开始学习" class="headerlink" title="开始学习"></a>开始学习</h1><p>所以，机器学习，就是……人工智能？</p>
<p>我们都或多或少了解人工智能的定义。关于人工智能，每个人有不同的定义，但有一点是共通的：</p>
<blockquote>
<p>人工智能是以人类智能相似的方式做出反应的机器智能。</p>
</blockquote>
<p>基本上，如果一台计算机做了一些看起来很聪明的事情，就可以将其标记为人工智能。</p>
<p>用一个可能遇到的例子解释：电脑游戏中通常有智能的敌人角色，他们通过不停跟在玩家周围的行事方式，使游戏更具挑战性。游戏的开发者通过一套规则来实现这一点：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">跟随玩家；</span><br><span class="line">如果玩家正在射击，找掩护；</span><br><span class="line">如果玩家停止射击，尝试攻击玩家；</span><br></pre></td></tr></table></figure></p>
<p>这些规则越多，游戏就越聪明。</p>
<p>电脑游戏的开发通常是有限的。玩家只能执行一些特定的、由开发人员设计的操作。所以，开发者可以想出一些看起来非常聪明的AI人物规则。(下面这张图里的人物很聪明吧？)<br><img src="https://cdn.shup.cn/machinelearning/intelligent.gif" width="400" height="300"></p>
<h1 id="并非所有的问题都可以通过规则来解决"><a href="#并非所有的问题都可以通过规则来解决" class="headerlink" title="并非所有的问题都可以通过规则来解决"></a>并非所有的问题都可以通过规则来解决</h1><p>假设我们想要一台电脑来检测这是不是狗的照片：<br><img src="https://cdn.shup.cn/machinelearning/dog.png" width="400" height="300"><br>如何为此任务定义规则？</p>
<ul>
<li>有四条腿？</li>
<li>白色的？</li>
<li>有皮毛？</li>
</ul>
<p>得到下图：<br><img src="https://cdn.shup.cn/machinelearning/chair.png" width="400" height="300"><br><strong>计算机视觉</strong>问题，比如识别一个物体，是很复杂的。但是人类的大脑几乎直观地解决了。所以，真的很难明确地定义规则。</p>
<h1 id="进入机器学习"><a href="#进入机器学习" class="headerlink" title="进入机器学习"></a>进入机器学习</h1><p>我们不用建立一个识别狗的系统，而是建立一个可以<strong>学习</strong>识别狗的系统。<br><img src="https://cdn.shup.cn/machinelearning/dogreg.png" width="400" height="300"><br>喂给它成千上万的图像资源，包含狗的，不包含狗的。让他自己<em>学习</em>定义狗的规则。</p>
<blockquote>
<p>机器学习就是让机器可以像人类一样学习。</p>
</blockquote>
<p>关键词<strong>“学习”</strong>是将机器学习与其他类型的人工智能区分开来的。</p>
<blockquote>
<p>“你说机器可以自己学习添加规则。那么，这些规则确实存在咯。我们只是不够努力去发现它们。“</p>
</blockquote>
<p>完全正确！如果努力+努力，可能会开发出一个基于检测狗规则的杰作。这个系统可能涵盖成千上万条规则，包含狗特征的方方面面。但如果现在想让这个系统再检测包含食物的图片呢？那我们只好扔掉之前所有的努力，从头开始，因为狗的那些规则都不适用(可能只有“热狗”适用吧)。<br><img src="https://cdn.shup.cn/machinelearning/hotdog.png" width="400" height="300"><br>简单的办法还是通过扔给它食物的图片来训练学习识别食物。<br><img src="https://cdn.shup.cn/machinelearning/food.png" width="400" height="300"><br>这才是机器学习的正确打开方式。我们有一个灵活的机器，可以学习和适应，而不是给它一套固定的规则。</p>
<h1 id="保持真实"><a href="#保持真实" class="headerlink" title="保持真实"></a>保持真实</h1><p>听起来像是建了一个鲜活的、可以学习的有机体，让它与小狗玩，以识别狗。然后，我们教它爱的意义，并说服它不要在崛起之后杀了所有人类。<br><img src="https://cdn.shup.cn/machinelearning/giphy.gif" width="400" height="300"><br>现实情况要复杂得多。我们希望机器学习做决定(通常根据预测)。那么从这个问题开始：<strong>人类如何做出预测？</strong></p>
<p>以下是如何进行预测的一个例子(中学生水平)，假设你进行弹簧实验，收集数据，并将其绘制在图表上。<br><img src="https://cdn.shup.cn/machinelearning/xy.png" width="400" height="300"><br>x轴是弹簧负重变量，y轴是测量结果。然后，在图上绘制<strong>趋势线</strong>。<br><img src="https://cdn.shup.cn/machinelearning/trendline.png" width="400" height="300"><br>这是对数据进行最佳建模的线。现在你有这条线，你可以做出预测。你可以选择一个未测量过的负重量，读出y轴的预测值。<br><img src="https://cdn.shup.cn/machinelearning/prediction.png" width="400" height="300"><br>使用<strong>数据</strong>，建立一个<strong>模型</strong>，并用它做出<strong>预测</strong>。如果你把这些步骤写成了一个可以执行的程序，这就是机器学习吗？不完全是，定义线性模型并用它来做出预测：这是一种机器学习技术，称为<strong>线性回归</strong>。</p>
<p>我们可以将模型编程到系统中，然后系统可以对这个弹簧做出预测。但如果要预测其他弹簧，就得编写新的代码。所以，如果我们教程序自己进行线性回归模型学习，那才是机器学习。</p>
<h1 id="Hocus-Pocus-诡计"><a href="#Hocus-Pocus-诡计" class="headerlink" title="Hocus Pocus(诡计)"></a>Hocus Pocus(诡计)</h1><p>从上面这个例子中可以学习一件事情，那就是：</p>
<blockquote>
<p><strong>机器学习不是变魔术</strong>。</p>
</blockquote>
<p>我们并没有建立一个能够学习一切的自我意识机体。弹簧的例子永远不会学会识别狗(也许能识别弹簧狗)。<br><img src="https://cdn.shup.cn/machinelearning/slinky.png" width="400" height="300"><br>我们建立一个可以学习一种特定类型模型的系统，所需要的只是确定何种模型。几乎所有的机器学习系统都具基于下面的模式：<br><img src="https://cdn.shup.cn/machinelearning/oeu.png" width="400" height="300"><br>系统给出一个基于模型的<strong>输出</strong>，然后<strong>评估</strong>这个输出以确定它有多糟糕，然后再<strong>更新</strong>模型，使未来的输出更好一些。机器学习就是针对不同问题建立一个可执行这个循环的系统。不同的问题，输出可能大相径庭。可能是<strong>聊天机器人</strong>的文本回应，或者是一个<strong>自动驾驶汽车</strong>决定是否需要踩刹车。实际的模型可以像弹簧的问题一样是线性的，也可能是一个更为复杂的、基于<strong>统计和概率的</strong>模型，又或是一个<strong>神经网络</strong>，旨在模拟人类大脑的工作方式。无论细节如何，几乎每个机器学习系统都在运行该循环。每循环一个周期，系统改善一点点。经过数千甚至数百万次的循环之后，即可以得到比任何人类处理同样任务上表现更好的系统。</p>
<p>机器学习有多种多样的应用，也需要融合各行各业的技术，所以它与许多其他领域相结合。这也是为什么当前机器学习是如此热门的原因。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>建立一个机器学习系统很复杂，但是理解机器学习的机理却很简单吧。下次遇到开头那样的聚会，不会再云里雾里、一片茫然了吧？你甚至可以抛出自己观点见解，让别人对你刮目相看！</p>
]]></content>
      
        
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[最常用的20个Linux命令(适用Ubuntu/Centos/MAC/Debian等)]]></title>
      <url>/2017/12/01/linux.html</url>
      <content type="html"><![CDATA[<p>接触过Linux的人都会知道，Linux中的命令的确是非常多，但其中只需要掌握最常用的命令就可以了。相对于Win、Mac、Ubuntu或者其他可视化系统界面，掌握这些命令可以大大提高操作速度。笔者主要是用Linux进行服务器的运维和Python编程，然而每个人用Linux的目的都不同，所以常用的命令也会有差异。在此总结一下，方便一下以后的查阅。<br><a id="more"></a></p>
<h1 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a>cd命令</h1><p>最基本，也是经常需要使用的命令，它用于切换当前目录，它的参数是要切换到的目录的路径，可以是绝对路径，也可以是相对路径。如：<br><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cd</span> <span class="string">/root/Docements</span> <span class="comment"># 切换到目录/root/Docements  </span></span><br><span class="line"><span class="keyword">cd</span> <span class="string">./path</span>          <span class="comment"># 切换到当前目录下的path目录中，“.”表示当前目录    </span></span><br><span class="line"><span class="keyword">cd</span> <span class="string">../path</span>         <span class="comment"># 切换到上层目录中的path目录中，“..”表示上一层目录</span></span><br></pre></td></tr></table></figure></p>
<h1 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h1><p>查看文件与文件夹的命令，list之意，它的参数非常多，下面就列出一些常用的参数吧，如下：<br><figure class="highlight haml"><table><tr><td class="code"><pre><span class="line">-<span class="ruby">l <span class="comment"># 列出长数据串，包含文件的属性与权限数据等  </span></span></span><br><span class="line"><span class="ruby">-a <span class="comment"># 列出全部的文件，连同隐藏文件（开头为.的文件）一起列出来（常用）  </span></span></span><br><span class="line"><span class="ruby">-d <span class="comment"># 仅列出目录本身，而不是列出目录的文件数据  </span></span></span><br><span class="line"><span class="ruby">-h <span class="comment"># 将文件容量以较易读的方式（GB，kB等）列出来  </span></span></span><br><span class="line"><span class="ruby">-R <span class="comment"># 连同子目录的内容一起列出（递归列出），等于该目录下的所有文件都会显示出来</span></span></span><br></pre></td></tr></table></figure></p>
<p>注：这些参数也可以组合使用，下面举两个例子：<br><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ls</span> -l <span class="comment"># 以长数据串的形式列出当前目录下的数据文件和目录  </span></span><br><span class="line"><span class="keyword">ls</span> -lR <span class="comment"># 以长数据串的形式列出当前目录下的所有文件</span></span><br></pre></td></tr></table></figure></p>
<h1 id="mkdir命令"><a href="#mkdir命令" class="headerlink" title="mkdir命令"></a>mkdir命令</h1><p>makedir之意，即创建一个新的文件夹或子文件夹。常用参数如下：<br><figure class="highlight hsp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mkdir</span> [-p] DirName <span class="meta"># 参数p代表parents，表示递归创建目录。</span></span><br></pre></td></tr></table></figure></p>
<p>例如：<br><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">mkdir <span class="keyword">new</span><span class="type">folder</span></span><br><span class="line"><span class="type">mkdir</span> <span class="keyword">new</span><span class="type">folder</span>/a/b -p</span><br></pre></td></tr></table></figure></p>
<p>注：如果要创建目录a并创建目录a的子目录b，没有用-p的情况下是<code>mkdir</code>2次<br>如果用-p可以直接创建2个目录<code>mkdir -p</code>目录a子目录b就可以。</p>
<h1 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令"></a>grep命令</h1><p>该命令常用于分析一行的信息，若当中有我们所需要的信息，就将该行显示出来，该命令通常与管道命令一起使用，用于对一些命令的输出进行筛选加工等等，它的简单语法为<br><figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">grep [-acinv] [--color=auto] <span class="string">'查找字符串'</span> filename</span><br></pre></td></tr></table></figure></p>
<p>它的常用参数如下：<br><figure class="highlight haml"><table><tr><td class="code"><pre><span class="line">-<span class="ruby">a ：将binary文件以text文件的方式查找数据  </span></span><br><span class="line"><span class="ruby">-c ：计算找到‘查找字符串’的次数  </span></span><br><span class="line"><span class="ruby">-i ：忽略大小写的区别，即把大小写视为相同  </span></span><br><span class="line"><span class="ruby">-v ：反向选择，即显示出没有‘查找字符串’内容的那一行  </span></span><br><span class="line"><span class="ruby"><span class="comment"># 例如：  </span></span></span><br><span class="line"><span class="ruby"><span class="comment"># 取出文件/etc/man.config中包含MANPATH的行，并把找到的关键字加上颜色  </span></span></span><br><span class="line"><span class="ruby">grep --color=auto <span class="string">'MANPATH'</span> /etc/man.config  </span></span><br><span class="line"><span class="ruby"><span class="comment"># 把ls -l的输出中包含字母file（不区分大小写）的内容输出  </span></span></span><br><span class="line"><span class="ruby">ls -l <span class="params">| grep -i file</span></span></span><br></pre></td></tr></table></figure></p>
<h1 id="find命令"><a href="#find命令" class="headerlink" title="find命令"></a>find命令</h1><p>这是一个基于查找的功能非常强大的命令，相对而言，它的使用也相对较为复杂，参数也比较多，所以在这里将给把它们分类列出，它的基本语法如下：<br><figure class="highlight haml"><table><tr><td class="code"><pre><span class="line">find [PATH] [option] [action]  </span><br><span class="line">  </span><br><span class="line"># 与时间有关的参数：  </span><br><span class="line">-<span class="ruby">mtime n <span class="comment"># n为数字，意思为在n天之前的“一天内”被更改过的文件；  </span></span></span><br><span class="line"><span class="ruby">-mtime +n <span class="comment"># 列出在n天之前（不含n天本身）被更改过的文件名；  </span></span></span><br><span class="line"><span class="ruby">-mtime -n <span class="comment"># 列出在n天之内（含n天本身）被更改过的文件名；  </span></span></span><br><span class="line"><span class="ruby">-newer file <span class="comment"># 列出比file还要新的文件名  </span></span></span><br><span class="line"><span class="ruby"><span class="comment"># 例如：  </span></span></span><br><span class="line"><span class="ruby">find /root -mtime <span class="number">0</span> <span class="comment"># 在当前目录下查找今天之内有改动的文件  </span></span></span><br><span class="line"><span class="ruby">  </span></span><br><span class="line"><span class="ruby"><span class="comment"># 与用户或用户组名有关的参数：  </span></span></span><br><span class="line"><span class="ruby">-user name <span class="comment"># 列出文件所有者为name的文件  </span></span></span><br><span class="line"><span class="ruby">-group name <span class="comment"># 列出文件所属用户组为name的文件  </span></span></span><br><span class="line"><span class="ruby">-uid n <span class="comment"># 列出文件所有者为用户ID为n的文件  </span></span></span><br><span class="line"><span class="ruby">-gid n <span class="comment"># 列出文件所属用户组为用户组ID为n的文件  </span></span></span><br><span class="line"><span class="ruby"><span class="comment"># 例如：  </span></span></span><br><span class="line"><span class="ruby">find /home/ljianhui -user ljianhui <span class="comment"># 在目录/home/ljianhui中找出所有者为ljianhui的文件  </span></span></span><br><span class="line"><span class="ruby">  </span></span><br><span class="line"><span class="ruby"><span class="comment"># 与文件权限及名称有关的参数：  </span></span></span><br><span class="line"><span class="ruby">-name filename <span class="comment"># 找出文件名为filename的文件  </span></span></span><br><span class="line"><span class="ruby">-size [+-]SIZE <span class="comment"># 找出比SIZE还要大（+）或小（-）的文件  </span></span></span><br><span class="line"><span class="ruby">-tpye TYPE <span class="comment"># 查找文件的类型为TYPE的文件，TYPE的值主要有：一般文件（f)、设备文件（b、c)、目录（d）、连接文件（l）、socket（s）、FIFO管道文件（p）；  </span></span></span><br><span class="line"><span class="ruby">-perm mode <span class="comment"># 查找文件权限刚好等于mode的文件，mode用数字表示，如0755；  </span></span></span><br><span class="line"><span class="ruby">-perm -mode <span class="comment"># 查找文件权限必须要全部包括mode权限的文件，mode用数字表示  </span></span></span><br><span class="line"><span class="ruby">-perm +mode <span class="comment"># 查找文件权限包含任一mode的权限的文件，mode用数字表示  </span></span></span><br><span class="line"><span class="ruby"><span class="comment"># 例如：  </span></span></span><br><span class="line"><span class="ruby">find / -name passwd <span class="comment"># 查找文件名为passwd的文件  </span></span></span><br><span class="line"><span class="ruby">find . -perm <span class="number">0755</span> <span class="comment"># 查找当前目录中文件权限的0755的文件  </span></span></span><br><span class="line"><span class="ruby">find . -size +<span class="number">12</span>k <span class="comment"># 查找当前目录中大于12KB的文件，注意c表示byte</span></span></span><br></pre></td></tr></table></figure></p>
<h1 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a>cp命令</h1><p>该命令用于复制文件，copy之意，它还可以把多个文件一次性地复制到一个目录下，它的常用参数如下：<br><figure class="highlight haml"><table><tr><td class="code"><pre><span class="line">-<span class="ruby">a <span class="comment"># 将文件的特性一起复制  </span></span></span><br><span class="line"><span class="ruby">-p <span class="comment"># 连同文件的属性一起复制，而非使用默认方式，与-a相似，常用于备份  </span></span></span><br><span class="line"><span class="ruby">-i <span class="comment"># 若目标文件已经存在时，在覆盖时会先询问操作的进行  </span></span></span><br><span class="line"><span class="ruby">-r <span class="comment"># 递归持续复制，用于目录的复制行为  </span></span></span><br><span class="line"><span class="ruby">-u <span class="comment"># 目标文件与源文件有差异时才会复制</span></span></span><br></pre></td></tr></table></figure></p>
<p>例如 ：<br><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cp</span> -a file1 file2 <span class="meta"># 连同文件的所有特性把文件file1复制成文件file2</span></span><br><span class="line"><span class="keyword">cp</span> file1 file2 file3 dir <span class="meta"># 把文件file1、file2、file3复制到目录dir中</span></span><br></pre></td></tr></table></figure></p>
<h1 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h1><p>该命令用于移动文件、目录或更名，move之意，它的常用参数如下：<br><figure class="highlight haml"><table><tr><td class="code"><pre><span class="line">-<span class="ruby">f <span class="comment"># force强制的意思，如果目标文件已经存在，不会询问而直接覆盖  </span></span></span><br><span class="line"><span class="ruby">-i <span class="comment"># 若目标文件已经存在，就会询问是否覆盖  </span></span></span><br><span class="line"><span class="ruby">-u <span class="comment"># 若目标文件已经存在，且比目标文件新，才会更新</span></span></span><br></pre></td></tr></table></figure></p>
<p>注：该命令可以把一个文件或多个文件一次移动一个文件夹中，但是最后一个目标文件一定要是“目录”。</p>
<p>例如：<br><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">mv file1 file2 file3 <span class="keyword">dir </span><span class="comment"># 把文件file1、file2、file3移动到目录dir中  </span></span><br><span class="line">mv file1 file2 <span class="comment"># 把文件file1重命名为file2</span></span><br></pre></td></tr></table></figure></p>
<h1 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a>rm命令</h1><p>该命令用于删除文件或目录，remove之意，它的常用参数如下：<br><figure class="highlight haml"><table><tr><td class="code"><pre><span class="line">-<span class="ruby">f <span class="comment"># 就是force的意思，忽略不存在的文件，不会出现警告消息  </span></span></span><br><span class="line"><span class="ruby">-i <span class="comment"># 互动模式，在删除前会询问用户是否操作  </span></span></span><br><span class="line"><span class="ruby">-r <span class="comment"># 递归删除，最常用于目录删除，它是一个非常危险的参数</span></span></span><br></pre></td></tr></table></figure></p>
<p>例如：<br><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">rm</span> -i <span class="keyword">file</span> # 删除文件<span class="keyword">file</span>，在删除之前会询问是否进行该操作  </span><br><span class="line"><span class="keyword">rm</span> -fr <span class="keyword">dir</span> # 强制删除目录<span class="keyword">dir</span>中的所有文件</span><br></pre></td></tr></table></figure></p>
<h1 id="ps命令"><a href="#ps命令" class="headerlink" title="ps命令"></a>ps命令</h1><p>该命令用于将某个时间点的进程运行情况选取下来并输出，process之意，它的常用参数如下：<br><figure class="highlight haml"><table><tr><td class="code"><pre><span class="line">-<span class="ruby">A <span class="comment"># 所有的进程均显示出来  </span></span></span><br><span class="line"><span class="ruby">-a <span class="comment"># 不与terminal有关的所有进程  </span></span></span><br><span class="line"><span class="ruby">-u <span class="comment"># 有效用户的相关进程  </span></span></span><br><span class="line"><span class="ruby">-x <span class="comment"># 一般与a参数一起使用，可列出较完整的信息  </span></span></span><br><span class="line"><span class="ruby">-l <span class="comment"># 较长，较详细地将PID的信息列出</span></span></span><br></pre></td></tr></table></figure></p>
<p>其实我们只要记住ps一般使用的命令参数搭配即可，它们并不多，如下：<br><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">ps</span> aux <span class="comment"># 查看系统所有的进程数据  </span></span><br><span class="line">ps ax <span class="comment"># 查看不与terminal有关的所有进程  </span></span><br><span class="line">ps -lA <span class="comment"># 查看系统所有的进程数据  </span></span><br><span class="line">ps axjf <span class="comment"># 查看连同一部分进程树状态</span></span><br></pre></td></tr></table></figure></p>
<h1 id="kill命令"><a href="#kill命令" class="headerlink" title="kill命令"></a>kill命令</h1><p>该命令用于向某个工作（%jobnumber）或者是某个PID（数字）传送一个信号，它通常与<code>ps</code>和<code>jobs</code>命令一起使用，它的基本语法如下：<br><figure class="highlight qml"><table><tr><td class="code"><pre><span class="line">kill -<span class="keyword">signal</span><span class="string"> PID</span></span><br></pre></td></tr></table></figure></p>
<p><strong>signal的常用参数如下：</strong><br>注：最前面的数字为信号的代号，使用时可以用代号代替相应的信号。<br><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>：SIGHUP <span class="meta"># 启动被终止的进程  </span></span><br><span class="line"><span class="number">2</span>：SIGINT <span class="meta"># 相当于输入ctrl+c，中断一个程序的进行  </span></span><br><span class="line"><span class="number">9</span>：SIGKILL <span class="meta"># 强制中断一个进程的进行  </span></span><br><span class="line"><span class="number">15</span>：SIGTERM <span class="meta"># 以正常的结束进程方式来终止进程  </span></span><br><span class="line"><span class="number">17</span>：SIGSTOP <span class="meta"># 相当于输入ctrl+z，暂停一个进程的进行</span></span><br></pre></td></tr></table></figure></p>
<p>例如：<br><figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以正常的结束进程方式来终于第一个后台工作，可用jobs命令查看后台中的第一个工作进程  </span></span><br><span class="line"><span class="keyword">kill</span> -SIGTERM %1   </span><br><span class="line"><span class="comment"># 重新改动进程ID为PID的进程，PID可用ps命令通过管道命令加上grep命令进行筛选获得  </span></span><br><span class="line"><span class="keyword">kill</span> -SIGHUP PID</span><br></pre></td></tr></table></figure></p>
<h1 id="killall命令"><a href="#killall命令" class="headerlink" title="killall命令"></a>killall命令</h1><p>该命令用于向一个命令启动的进程发送一个信号，它的一般语法如下：<br><figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">killall <span class="string">[-iIe]</span> <span class="string">[command name]</span></span><br></pre></td></tr></table></figure></p>
<p>它的参数如下：<br><figure class="highlight haml"><table><tr><td class="code"><pre><span class="line">-<span class="ruby">i <span class="comment"># 交互式的意思，若需要删除时，会询问用户  </span></span></span><br><span class="line"><span class="ruby">-e <span class="comment"># 表示后面接的command name要一致，但command name不能超过15个字符  </span></span></span><br><span class="line"><span class="ruby">-I <span class="comment"># 命令名称忽略大小写  </span></span></span><br><span class="line"><span class="ruby"><span class="comment"># 例如：  </span></span></span><br><span class="line"><span class="ruby">killall -SIGHUP syslogd <span class="comment"># 重新启动syslogd</span></span></span><br></pre></td></tr></table></figure></p>
<h1 id="file命令"><a href="#file命令" class="headerlink" title="file命令"></a>file命令</h1><p>该命令用于判断接在file命令后的文件的基本数据，因为在Linux下文件的类型并不是以后缀为分的，所以这个命令对我们来说就很有用了，它的用法非常简单，基本语法如下：<br><figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">file</span> <span class="keyword">filename</span>  </span><br><span class="line"><span class="comment"># 例如：  </span></span><br><span class="line"><span class="keyword">file</span> ./test</span><br></pre></td></tr></table></figure></p>
<h1 id="tar命令"><a href="#tar命令" class="headerlink" title="tar命令"></a>tar命令</h1><p>该命令用于对文件进行打包，默认情况并不会压缩，如果指定了相应的参数，它还会调用相应的压缩程序（如gzip和bzip等）进行压缩和解压。它的常用参数如下：<br><figure class="highlight haml"><table><tr><td class="code"><pre><span class="line">-<span class="ruby">c <span class="comment"># 新建打包文件  </span></span></span><br><span class="line"><span class="ruby">-t <span class="comment"># 查看打包文件的内容含有哪些文件名  </span></span></span><br><span class="line"><span class="ruby">-x <span class="comment"># 解打包或解压缩的功能，可以搭配-C（大写）指定解压的目录，注意-c,-t,-x不能同时出现在同一条命令中  </span></span></span><br><span class="line"><span class="ruby">-j <span class="comment"># 通过bzip2的支持进行压缩/解压缩  </span></span></span><br><span class="line"><span class="ruby">-z <span class="comment"># 通过gzip的支持进行压缩/解压缩  </span></span></span><br><span class="line"><span class="ruby">-v <span class="comment"># 在压缩/解压缩过程中，将正在处理的文件名显示出来  </span></span></span><br><span class="line"><span class="ruby">-f filename <span class="comment"># filename为要处理的文件  </span></span></span><br><span class="line"><span class="ruby">-C dir <span class="comment"># 指定压缩/解压缩的目录dir</span></span></span><br></pre></td></tr></table></figure></p>
<p>上面的解说可以已经让你晕过去了，但是通常只需要记住下面三条命令即可：<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">压缩：tar -jcv -f filename<span class="selector-class">.tar</span><span class="selector-class">.bz2</span> /要被处理的文件或目录名称  </span><br><span class="line">查询：tar -jtv -f filename<span class="selector-class">.tar</span><span class="selector-class">.bz2</span>  </span><br><span class="line">解压：tar -jxv -f filename<span class="selector-class">.tar</span><span class="selector-class">.bz2</span> -C /欲解压缩的目录</span><br></pre></td></tr></table></figure></p>
<p>注：文件名并不一定要以后缀tar.bz2结尾，这里主要是为了说明使用的压缩程序为bzip2</p>
<h1 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a>cat命令</h1><p>该命令用于查看文本文件的内容，后接要查看的文件名，通常可用管道<code>|</code>与<code>more</code>和<code>less</code>一起使用，从而可以一页页地查看数据。例如：<br><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">cat <span class="built_in">text</span> | less <span class="comment"># 查看text文件中的内容  </span></span><br><span class="line"><span class="comment"># 注：这条命令也可以使用less text来代替</span></span><br></pre></td></tr></table></figure></p>
<h1 id="chgrp命令"><a href="#chgrp命令" class="headerlink" title="chgrp命令"></a>chgrp命令</h1><p>该命令用于改变文件所属用户组，它的使用非常简单，它的基本用法如下：<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">chgrp [-R] dirname/filename  </span><br><span class="line">-R # 进行递归的持续对所有文件和子目录更改  </span><br><span class="line"><span class="comment"># 例如：  </span></span><br><span class="line">chgrp<span class="built_in"> users </span>-R ./dir # 递归地把dir目录下中的所有文件和子目录下所有文件的用户组修改为users</span><br></pre></td></tr></table></figure></p>
<h1 id="chown命令"><a href="#chown命令" class="headerlink" title="chown命令"></a>chown命令</h1><p>该命令用于改变文件的所有者，与<code>chgrp</code>命令的使用方法相同，只是修改的文件属性不同，不再详述。</p>
<h1 id="chmod命令"><a href="#chmod命令" class="headerlink" title="chmod命令"></a>chmod命令</h1><p>该命令用于改变文件的权限，一般的用法如下：<br><figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">chmod [-R] <span class="built_in">xyz</span> /文件或目录  </span><br><span class="line">-R <span class="meta"># 进行递归的持续更改，即连同子目录下的所有文件都会更改</span></span><br></pre></td></tr></table></figure></p>
<p>同时，<code>chmod</code>还可以使用u（user）、g（group）、o（other）、a（all）和+（加入）、-（删除）、=（设置）跟rwx搭配来对文件的权限进行更改。<br><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 例如：  </span></span><br><span class="line">chmod <span class="number">0755</span> <span class="built_in">file</span> <span class="comment"># 把file的文件权限改变为-rxwr-xr-x  </span></span><br><span class="line">chmod g+w <span class="built_in">file</span> <span class="comment"># 向file的文件权限中加入用户组可写权限</span></span><br></pre></td></tr></table></figure></p>
<h1 id="vim命令"><a href="#vim命令" class="headerlink" title="vim命令"></a>vim命令</h1><p>该命令主要用于文本编辑，它接一个或多个文件名作为参数，如果文件存在就打开，如果文件不存在就以该文件名创建一个文件。vim是一个非常好用的文本编辑器，它里面有很多非常好用的命令，在这里不再多说。你可以参考<a href="http://blog.csdn.net/vmboys/article/details/51331947" rel="external nofollow noopener noreferrer" target="_blank">vim常用操作</a>的详细说明。</p>
<h1 id="time命令"><a href="#time命令" class="headerlink" title="time命令"></a>time命令</h1><p>该命令用于测算一个命令（即程序）的执行时间。它的使用非常简单，就像平时输入命令一样，不过在命令的前面加入一个<code>time</code>即可，例如：<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">time</span> ./process  </span><br><span class="line"><span class="selector-tag">time</span> ps aux</span><br></pre></td></tr></table></figure></p>
<p>在程序或命令运行结束后，在最后输出了三个时间，它们分别是：</p>
<ul>
<li>user：用户CPU时间，命令执行完成花费的用户CPU时间，即命令在用户态中执行时间总和；</li>
<li>system：系统CPU时间，命令执行完成花费的系统CPU时间，即命令在核心态中执行时间总和；</li>
<li>real：实际时间，从command命令行开始执行到运行终止的消逝时间；</li>
</ul>
<p>注：用户CPU时间和系统CPU时间之和为CPU时间，即命令占用CPU执行的时间总和。实际时间要大于CPU时间，因为Linux是多任务操作系统，往往在执行一条命令时，系统还要处理其它任务。另一个需要注意的问题是即使每次执行相同命令，但所花费的时间也是不一样，其花费时间是与系统运行相关的。</p>
<h1 id="shutdown命令"><a href="#shutdown命令" class="headerlink" title="shutdown命令"></a>shutdown命令</h1><p>shutdown是最常用也是最安全的关机和重启命令，它会在关机之前调用fsck检查磁盘，其中-h和-r是最常用的参数，另外还有，硬关机：<code>halt</code>、立即关机：<code>poweroff</code>、重启：<code>reboot</code>等。其实这些命令基本上都是调用<code>shutdown</code>，例如：<br><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">halt</span>     <span class="comment"># 等同于 shutdown -h</span></span><br><span class="line">reboot   <span class="comment"># 等同于 shutdown -r</span></span><br><span class="line">poweroff <span class="comment"># 等同于 shutdown -h now</span></span><br><span class="line"></span><br><span class="line">-h <span class="comment"># 停止系统服务并关机  </span></span><br><span class="line">-r <span class="comment"># 停止系统服务后重启</span></span><br></pre></td></tr></table></figure></p>
<p><code>shutdown</code>基本上就下面几个用法：<br><figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line"><span class="built_in">shutdown</span> -h now  <span class="meta"># 立即关机  </span></span><br><span class="line"><span class="built_in">shutdown</span> -h <span class="number">10</span>:<span class="number">53</span>  <span class="meta"># 到10:53关机，如果该时间小于当前时间，则到隔天  </span></span><br><span class="line"><span class="built_in">shutdown</span> -h +<span class="number">10</span>  <span class="meta"># 10分钟后自动关机  </span></span><br><span class="line"><span class="built_in">shutdown</span> -r now  <span class="meta"># 立即重启  </span></span><br><span class="line"><span class="built_in">shutdown</span> -r +<span class="number">30</span>  <span class="meta"># 30分钟后重启并并发送通知给其它在线用户</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      
        
        <tags>
            
            <tag> Linux命令 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[让你的代码变得更简洁、干净]]></title>
      <url>/2017/11/29/cleancode.html</url>
      <content type="html"><![CDATA[<p> 你是否见过下面这样的代码？ </p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">String</span> getProductNames(List&lt;Product&gt; products) &#123;</span><br><span class="line">    StringBuilder strBuf = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">    strBuf.<span class="built_in">append</span>(products.<span class="built_in">get</span>(<span class="number">0</span>).name);</span><br><span class="line">    <span class="keyword">while</span> (i &lt; products.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        strBuf.<span class="built_in">append</span>(<span class="string">", "</span>);</span><br><span class="line">        strBuf.<span class="built_in">append</span>(products.<span class="built_in">get</span>(i++).name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strBuf.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>这样的代码存在于一些保留系统(<em>Legacy System</em>)中，通常很旧。当你看到这样的代码时，很可能感觉不太友好。</p>
<p>这段代码的问题在于：不仅太冗长，更重要的是它<strong>隐藏了逻辑</strong>（还有一些其他问题，后面讨论）。<strong>我们编写代码来解决问题</strong>，因此，不应该在代码中创造新的问题。请注意，当编写“系统代码”或者以高性能为目标的库时、或者我们需要解决的问题技术太过复杂时，是可以牺牲可读性。但是即便如此，还是应该尽量避免编写隐藏逻辑且晦涩难懂的代码。</p>
<p><em>罗伯特·马丁</em> (Bob大叔)在他的书《<a href="https://baike.baidu.com/item/Clean%20Code" rel="external nofollow noopener noreferrer" target="_blank"><strong>Clean Code</strong></a>》中提到 <em>“阅读代码和编写代码的时间比例远远超过10比1”</em>。在一些保留系统中，你要花费大量的时间试图理解<em>如何</em> 阅读代码，而不是实际阅读代码。测试和调试这样的系统也是非常棘手的，大多数情况下，你需要用非常规的方式完全来完成。</p>
<h1 id="代码也在讲故事"><a href="#代码也在讲故事" class="headerlink" title="代码也在讲故事"></a>代码也在讲故事</h1><p>写代码也是写作的一种。代码不应该隐藏解决问题的逻辑或算法。相反，它应该条理清晰的列出各种函数名称，模块等，甚至代码的格式看起来像已被谨慎和专业地处理过的。</p>
<p>看到下面这段代码有什么感觉？</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> calc(<span class="keyword">int</span> arr[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>;i&lt;arr.length;i=i +<span class="number">1</span> )</span><br><span class="line">      val = val+<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">sum</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (arr.length&gt;j) &#123;<span class="keyword">sum</span> += arr[j++] ;&#125;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="keyword">sum</span> - val;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码看起来像战后的战场。看上去碰过这段代码的开发者都很烦它，且尽力回避它，让它处于更糟的状态。凌乱的格式和糟糕的定义清楚地表明，不止一个开发人员掉过坑，听起来像<a href="https://baike.baidu.com/item/%E7%A0%B4%E7%AA%97%E7%90%86%E8%AE%BA" rel="external nofollow noopener noreferrer" target="_blank"><strong>破窗理论</strong></a>对吧？想明白这段代码的功能并不容易（不仅仅是因为你看代码时感觉辣眼睛），这段代码其实返回的是数组的总和减去元素的数量。让我们以更简单的方式来做到这一点：</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sumMinusCount(<span class="keyword">int</span> arr[]) &#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">sum</span> = IntStream.of(arr).<span class="keyword">sum</span>();</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">count</span> = arr.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">sum</span> - <span class="keyword">count</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，用Java 8的<em>Stream</em>，让代码更加简洁并增强可读性。</p>
<h1 id="干净的代码"><a href="#干净的代码" class="headerlink" title="干净的代码"></a>干净的代码</h1><p>干净的代码不是<em>让代码看起来漂亮</em>，而是<em>使代码更易于维护</em>。当代码太晦涩难懂时，大部分时间浪费在阅读上，导致开发者的生产力降低了，而且使用它的开发人员通常也会让它变得更糟，就像上面讲的那样。原因并不是因为他们无法理清代码，而是由于时间和精力的限制。碰到这样的代码时，很难估计修复bug、植入一个新模块或实现一个新功能需要多长时间，因为原框架和设计隐藏在代码中，不容易发现。因此，为了完成工作，最终会选择草草了事。干净的代码可以表明作者的意图，即便在代码中存在错误，也很容易找到并修复它，也可以长期节省维护时间。</p>
<p>解决（或提高）代码可维护性的方法是花费几个月（或更多）的时间来重构和清理，但是不管企业还是个人通常不太可能接受暂停开发，重构代码。所以，我们能做些什么？</p>
<h1 id="童子军原则"><a href="#童子军原则" class="headerlink" title="童子军原则"></a>童子军原则</h1><p>正如Bob大叔所说，“童子军原则”背后的想法其实非常简单：<em>让代码更干净！</em>任何时候你碰到旧的代码，应该先妥善地清理好它。不要只是快捷方式处理，让代码更难理解，而应该认真地对待。这个原则更多地关注开发者应该具有的心态，通过把代码变得更易于维护，让他们的日子过得更舒服。</p>
<p>在大多数情况下处理保留系统是很不容易的，特别是当没有测试或测试套件不再被维护的时候，仍然应该努力使代码更干净。关于如何编写更具表达性的代码，这篇文章更关注一些有用的、<strong>一般性</strong>的建议。</p>
<h1 id="编写前的思考"><a href="#编写前的思考" class="headerlink" title="编写前的思考"></a>编写前的思考</h1><p>有个常见的误解：开发的人员开发软件或系统时仅仅是写代码。事实并非如此，<strong>相反，我们编写代码来解决问题</strong>。代码只是一个媒介，而不是实际的解决方案。随便敲几个键盘是写代码吗？当然不是，因为不可能被电脑编译。同样，没有先考虑如何解决的问题就开始编写代码也不是常规做法。因此，当写代码时，必须三思而后行，以便通过代码提供的解决方案清晰且不模糊。不应该为了写代码而写代码，代码应该解决问题，而不是创建新的问题。</p>
<p>有没有在检查代码时，意识到代码完全错误，唯一的解决办法是从头再写？许多开发人员接到新任务，就立刻开始在IDE中输入内容。他们认为，这样做看起来像在认真工作。大多数情况下，这被证明是错误的方法，因为没有思考就开始写代码会导致错误的方向。当然，不排除一些非常有经验的开发人员可以立刻开始编写，并且仍然朝着正确的方向发展，但是大多数开发者在碰键盘前还是需要仔细计划好。</p>
<p>考虑一下下面这个例子:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Double&gt; drinks;</span><br><span class="line">    <span class="keyword">private</span> BillingStrategy strategy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(BillingStrategy strategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.drinks = <span class="keyword">new</span> ArrayList&lt;Double&gt;();</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">final</span> <span class="keyword">double</span> price, <span class="keyword">final</span> <span class="keyword">int</span> quantity)</span> </span>&#123;</span><br><span class="line">        drinks.add(strategy.getActPrice(price*quantity));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Payment of bill</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printBill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Double i : drinks) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Total due: "</span> + sum);</span><br><span class="line">        drinks.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">BillingStrategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getActPrice</span><span class="params">(<span class="keyword">final</span> <span class="keyword">double</span> rawPrice)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Normal billing strategy (unchanged price)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NormalStrategy</span> <span class="keyword">implements</span> <span class="title">BillingStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getActPrice</span><span class="params">(<span class="keyword">final</span> <span class="keyword">double</span> rawPrice)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rawPrice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码来源于<a href="https://en.wikipedia.org/wiki/Strategy_pattern#Java" rel="external nofollow noopener noreferrer" target="_blank">维基百科</a>。这个例子中的代码没有什么不好，是吧？其实不然，这段代码使用了<a href="https://baike.baidu.com/item/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/646307" rel="external nofollow noopener noreferrer" target="_blank"><em>Strategy Pattern</em></a>，表明它需要有一定的灵活性。但在这个例子中，与维基百科不同，只有一个策略实现，且并没有实现更多策略的计划。这里使用<em>Strategy Pattern</em>的意图可能会误导读者，通常实现一个Pattern需要费不少功夫，所以读者自然会想，用这个的原因是什么。<strong>YAGNI原则</strong>(<em>You aren’t going to need it</em>)，除非你需要它，否则别创建新功能，避免创建你不要的代码。预测未来需要什么是很难的，有时候过往的经验会有帮助，但是在大多数情况下，保持简单还是比较安全的。</p>
<p>使用Pattern帮助我们以一种易于沟通的优雅方式来解决特定的问题。如果本身问题不存在，读者将被误导，反而认为问题确实存在。请注意，并不是反对Pattern，问题是人们总是试图在Pattern解决的问题同时创造新问题，就因为他们知道Pattern这回事。</p>
<p>不要以为代码可以正常编译，就完活了！其实，在代码编写完成的时候，只是完成了一半，要继续工作使代码可以向读者传达我们的意图。</p>
<p>我们的工具集中有很多工具，要在适当的时候使用它们。仅仅因为每个人都在用框架和库就随大流是没有任何意义的。要了解他们到底解决了什么问题，学习以一种不隐匿的方式来使用它们。如何处理框架和库，这里<em>Bob大叔</em> 还有一个很棒的帖子：《<a href="https://8thlight.com/blog/uncle-bob/2015/08/06/let-the-magic-die.html" rel="external nofollow noopener noreferrer" target="_blank"><em>Make the Magic go away</em></a>》。</p>
<h1 id="提高表达性"><a href="#提高表达性" class="headerlink" title="提高表达性"></a>提高表达性</h1><p>如今，许多编程语言都支持<em>Stream</em>来帮助我们编写表达性代码，例如Java，Kotlin，JavaScript等。<em>Stream</em>已经用<code>if</code>语句取代了冗长的循环，相对于命令式编程，帮助我们用更具声明式编程的方式来考虑数据转换。为了要找到所有小于某个值的元素就反复声明是没有意义的，只需简单地将过滤器应用于<em>Stream</em>。</p>
<ul>
<li><strong>命令式编程</strong>：命令机器<em>如何</em> 去做事情<em>(how)</em>，这样不管你想要的<em>是什么(what)</em>，它都会按照你的命令实现。</li>
<li><strong>声明式编程</strong>：告诉机器你想要的<em>是什么(what)</em>，让机器想出<em>如何</em> 去做<em>(how)</em>。</li>
</ul>
<p>几乎所有支持<em>Stream</em>的语言都有<em>Map, filter 和 reduce</em>。所以，每个人都可以理解你写的东西，就像每个人都能理解一个循环或者一个<code>if</code>语句一样。用这样的表达式来处理数据是非常强大的。首先你就不用测试这个功能。有没有注意到第一个例子中的<em>差一错误</em> ？这也使我们走向了<a href="https://baike.baidu.com/item/Functional%20Programming" rel="external nofollow noopener noreferrer" target="_blank">函数式编程</a>。</p>
<p>第一个例子中的基于<em>Stream</em> 的解决方案如下：</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">String</span> getProductNames(<span class="built_in">List</span>&lt;Product&gt; products) &#123;</span><br><span class="line">    <span class="keyword">return</span> products.stream()</span><br><span class="line">            .<span class="built_in">map</span>(p -&gt; p.name)</span><br><span class="line">            .collect(Collectors.joining(<span class="string">", "</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单又干净，很容易理解它做什么。现在，考虑下面的例子：</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="literal">void</span> getPositiveNumbers(<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; l1, <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; l2) &#123;</span><br><span class="line">    for (<span class="built_in">Integer</span> el1: l1)</span><br><span class="line">        <span class="keyword">if</span> (el1 &gt; <span class="number">0</span>)</span><br><span class="line">            l2.add(el1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当你调用这个method时，第二个参数会改变吗？这个method是按照编写的去实现吗？Method的名称是否合适？你真的能“get”吗？</p>
<p>这样呢？</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;Integer&gt; getPositiveNumbers(<span class="built_in">List</span>&lt;Integer&gt; numbers) &#123;</span><br><span class="line">    <span class="keyword">return</span> numbers.stream()</span><br><span class="line">        .filter(<span class="built_in">num</span> -&gt; <span class="built_in">num</span> &gt; <span class="number">0</span>)</span><br><span class="line">        .collect(toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，返回值是一个新的列表，没有参数受到影响。我们只是读取参数并产生一个新的结果，但要理解这个method在做什么以及如何使用它，第二段显然更容易。这种method也可以很容易地与其他method组合，一般而言，组合是<em>Stream</em>和函数式编程的最重要的好处之一。组合能使我们从更高层次的数据转换、过滤等方面进行思考，并编写出更具声明式编程和表达性的代码，让代码表达我们<strong>想要实现的(what)</strong>而不是<strong>如何完成的(how)</strong>，这大大改善了代码的可读性。</p>
<p>把一个问题分解成多个子问题，解决每一个子问题，然后组合这些解决方案，为最初的问题提供解决方案，就容易多了。但另一方面，当主要目标是性能时，命令式编程可能又是必不可少的。</p>
<p>请注意，Jave 8中的<code>toList()</code>收集器返回一个可变列表，而在函数式编程中，我们通常使用不可变数据结构。不过，生成新数据并将参数视为只读可以提高method可读性和表现。虽然有些method可能有副作用，但对于一种method来说，要么有副作用（表现为<em>command</em>），要么有返回值（表现为<em>query</em>），不会同时存在。</p>
<p>写更具表达性的代码不是一件容易的事情。爱因斯坦说过：<em>“If you can’t explain it simply, you don’t understand it well enough”</em>。所以，当看到抽象层次代码混合时，例如与数据访问对象(<em>DAO</em>)交互的UI类，或者直接与数据库talk，或者低层次的细节在不应该暴露的时候暴露，可以说不仅违反了<a href="https://baike.baidu.com/item/%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99" rel="external nofollow noopener noreferrer" target="_blank">单一职责原则</a>，而且还有些混乱。通过使用注释来解决并非最佳解决方案。有人写的越简单、越具表达性，说明他对这个问题的理解就越好。</p>
<h1 id="拥抱不可变对象"><a href="#拥抱不可变对象" class="headerlink" title="拥抱不可变对象"></a>拥抱不可变对象</h1><p>当对象的状态发生变化，而又没有注意到它的时候，是非常让人困惑的。对构造一半的对象使用<code>return</code>时也是很危险的，特别是处理多线程的程序时。而不可变对象对多线程是安全的，也是完美的缓存对象，因为它们的状态不会改变。</p>
<p>但是为什么选择可变对象呢？最有可能的原因是为了性能表现，因为占用的内存会少一些，因为改变是在原地(<em>in-place</em>)进行的。而且，让一个对象的状态在其整个生命周期中发生变化是很自然的，这是我们在面向对象编程(<em>OOP</em>)中学到的。这些年来，我们一直在写程序，其中大部分的对象都是可变的。</p>
<p>今时不同往日，机器内存的数量、性能比之前翻了N个数量级，真正面临的问题是可扩展性。处理器的速度虽然不再像过去十几年那样猛增了，但现在有了N多核的CPU。所以，需要利用好现在的情况来规划好程序。由于程序需要能够在多个内核上运行，所以要以一种安全的方式来编写。使用可变对象，必须处理好locking以确保其状态的一致性。并发（<a href="http://blog.csdn.net/kkkloveyou/article/details/50561269" rel="external nofollow noopener noreferrer" target="_blank">详解</a>）不是很好处理的。而不可变对象（<em>状态在对象被创建之后就不再变化</em>）在多线程和处理器之间共享是固有安全的，且不需要同步的特性为创建具有低延迟和高吞吐量的系统提供了机会。因此，不可变对象是实现可扩展，更安全的选择。</p>
<p>除了可扩展的好处，不可变对象使我们的代码更简洁、干净了。在上一节的示例中，作为参数传递的集合在调用method后发生了改变。如果是不可变集合，则是不允许的。因此，不可变对象可以促进更好的解决方案。另外，由于状态不变，读者也不需要费心思记，只需要将一个对象名称与一个值关联起来。</p>
<blockquote>
<p><strong>程序必须是为人们阅读而写的，只是偶尔地让机器执行。</strong></p>
<p>—— <a href="https://en.wikipedia.org/wiki/Hal_Abelson" rel="external nofollow noopener noreferrer" target="_blank">Harold Abelson</a>，<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E8%A7%A3%E9%87%8A" rel="external nofollow noopener noreferrer" target="_blank">《计算机程序的构造和解释》</a></p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> 干净代码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[利用免费的Google Cloud来部署科学上网神器SS]]></title>
      <url>/2017/11/23/ss.html</url>
      <content type="html"><![CDATA[<p>之前一直想搞个搬瓦工或者vultr的VPS来部署SS，实现科(V)学(P)上(N)网，但始终抢不到优惠的实例。偶然间发现Google Cloud在免费，而且貌似免费期从之前的2个月提高到1年，这样看来不用花一分钱，即可实现爱(翻)国(墙)上网，还可以再享受配置、性能更高、更稳定Google服务器，岂不美哉！<br><a id="more"></a></p>
<h1 id="Google-Cloud免费简介"><a href="#Google-Cloud免费简介" class="headerlink" title="Google Cloud免费简介"></a>Google Cloud免费简介</h1><p>Google Cloud顾名思义即Google提供的云计算服务，和国内的阿里云、腾讯云、百度云类似。提供的服务无非也就那几大类：基础云计算服务、大数据类、物联网、CDN等等。免费以300刀赠金形式，可以体验所有产品当然也包括Compute Engine(即VPS)，需要注意Google的云主机计费方式与国内不同之处在于：国内一般是全包，而Google是云主机、公网IP和流量分开计费，需确保你在一年内的消费不超过300刀，后面会详细讲。<br><img src="https://cdn.shup.cn/ss/free.png" width="400" height="300"></p>
<h1 id="申请与开通VPS主机"><a href="#申请与开通VPS主机" class="headerlink" title="申请与开通VPS主机"></a>申请与开通VPS主机</h1><p>在一切操作前，你需要先有一个临时的科(V)学(P)上(N)网环境，因为注册和配置Google云服务的工作需要在Google网站上完成。可以在手机里操作，目前有很多相关APP有免费使用时长，半个小时足以。</p>
<p>另外，你需要准备好：</p>
<ol>
<li>一张Visa或者万事达的信用卡(会扣1美元验证卡真实性，几分钟后就会退还。)</li>
<li>一个美国电话号码(可以用<strong>iPlum</strong>。非必须，仅仅为提高通过率，目前号码不需要验证，所以非真实号码应该可以。)</li>
<li>一个美国地址(自己去搜索，地址需要真实)</li>
</ol>
<p>准备就绪：</p>
<ol>
<li>登陆Google Cloud主页：<code>cloud.google.com</code>，点击<strong>TRY IT FREE</strong>，登陆你的Google账号。</li>
<li>地区选择美国，然后同意服务条款后，账户类型选择<strong>个人</strong>，填上地址、信用卡信息，即可开通账户。<img src="https://cdn.shup.cn/ss/first.png" width="400" height="300"></li>
<li>开通后创建VM实例，按照下面2张图配置即可，笔者选的是1核1G内存10G硬盘CENTOS6系统，asia-east1-c节点(台湾)。也可根据自己需求选择配置。另外在网络那里选择添加外部静态IP(即公网IP地址)。最后点创建即可开通云主机。<img src="https://cdn.shup.cn/ss/kaitong1.png" width="400" height="300" title="配置云主机">
<img src="https://cdn.shup.cn/ss/kaitong2.png" width="400" height="300" title="配置公网IP">
这里说一下配置的选择及价格：主机的价格表不在此列举，自己选择适合的。公网IP基本上是免费，那就来梳理一下流量的计费方式：</li>
</ol>
<table>
<thead>
<tr>
<th>流量类型</th>
<th>价格</th>
</tr>
</thead>
<tbody>
<tr>
<td>入口</td>
<td>免费</td>
</tr>
<tr>
<td>出口*到同一区域</td>
<td>免费</td>
</tr>
<tr>
<td>出口在同一区域内不同的谷歌云平台服务</td>
<td>免费</td>
</tr>
<tr>
<td>出口到谷歌产品（如YouTube，Google地图，驱动器）</td>
<td>不收费**</td>
</tr>
<tr>
<td>在同一地区区域之间的出口（每GB）</td>
<td>$ 0.01</td>
</tr>
<tr>
<td>在美国国内地区之间的出口（每GB）</td>
<td>$ 0.01</td>
</tr>
<tr>
<td>洲际出口</td>
<td>参考下面表格</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>每月使用</th>
<th>网络(出)全球(不包括中国和澳大利亚，但包括香港)(每GB)</th>
<th>网络(出)中国(不包括香港)(每GB)</th>
<th>网络(出)澳大利亚(每GB)</th>
<th>网络(入)</th>
</tr>
</thead>
<tbody>
<tr>
<td>0-1 TB</td>
<td>$ 0.12</td>
<td>$ 0.23</td>
<td>$ 0.19</td>
<td>免费</td>
</tr>
<tr>
<td>1-10 TB</td>
<td>$ 0.11</td>
<td>$ 0.22</td>
<td>$ 0.18</td>
<td>免费</td>
</tr>
<tr>
<td>10+ TB</td>
<td>$为0.08</td>
<td>$ 0.20</td>
<td>$ 0.15</td>
<td>免费</td>
</tr>
</tbody>
</table>
<p>可以看出如果每月流量不超过<strong>1TB</strong>，就是$0.23月/GB。以最低配主机(如果仅仅用于科学上网，最低配没问题)为例，$5/月，一年是$60，还剩下$240用于流量的开销，240 / 0.23 = 1043GB， 1043 / 12个月 = 86GB 也就是每个月用 86GB流量，足够了。当然也可以选择更高配置的主机，这样流量少一点，自己权衡。</p>
<h1 id="配置防火墙"><a href="#配置防火墙" class="headerlink" title="配置防火墙"></a>配置防火墙</h1><p>开通主机后，因为后面要配置SS，默认的防火墙限制太多，需要修改防火墙规则。<br>在<code>控制台/VPC网络/防火墙规则</code>里，名称随便写，其他按下图配置即可。IP地址范围： <code>0.0.0.0/0</code><br><img src="https://cdn.shup.cn/ss/firewall.png" width="400" height="300"></p>
<h1 id="配置SSH"><a href="#配置SSH" class="headerlink" title="配置SSH"></a>配置SSH</h1><ol>
<li><p>用  PuTTYgen生成密钥<br>使用SSH工具<code>Xshell</code>或者<code>Putty</code>，这里以Putty为例，使用方法参考<a href="https://shup.cn/2017/11/16/hexo.html#SSH%E5%B7%A5%E5%85%B7">之前文章</a>，Putty安装好后程序包里有一个PuttyGen工具，打开后，直接点击<code>Generate</code>来生成一对密钥用于登陆SSH。<br><strong>注意</strong>： 生成好后在<code>key comment</code>处，原本生成的应该是rsa-key-20171123，需要修改成rsa-key-20170905<code>XXXX</code>，<code>XXXX</code>是你申请Google Cloud 时，“XXXX@gmail.com” 前的字符，说白了就是你邮箱的用户名。<br><strong>完成后将 public key 保存，保存为<code>.pub</code>格式文件，然后保存 private key，保存为<code>.ppk</code>文件格式！</strong></p>
</li>
<li><p>Google Cloud控制台 导入公钥<br>在<code>控制台/compute engine/元数据</code>中，右边点击<code>SSH密钥</code>，点击修改，添加刚刚保存的公钥<code>.pub</code>文件里的内容进去保存即可。</p>
</li>
<li><p>Putty里导入私钥 连接实例<br>打开Putty ，在<code>Connection/SSH/Auth</code>, 导入刚刚保存的私钥<code>.ppk</code>文件。如下图。接下来回到<code>session</code>，在Host Name (or IP address)中填入步骤1修改过的 <code>Key comment ＋@实例 ip</code>(比如rsa-key-20170905name@8.8.8.8)，即可登录SSH。</p>
<img src="https://cdn.shup.cn/ss/putty.png" width="400" height="300">
<p>连接成功后，输入<code>sudo -i</code>即可获得root权限。</p>
<img src="https://cdn.shup.cn/ss/ssh.png" width="400" height="300">
<h1 id="SS的安装与配置"><a href="#SS的安装与配置" class="headerlink" title="SS的安装与配置"></a>SS的安装与配置</h1><p>先来说说SS特点 ：</p>
</li>
</ol>
<ul>
<li>省电（在电量查看里几乎看不到它的身影）</li>
<li>支持开机自启动，且断网无影响，无需手动重连</li>
<li>可使用自己的服务器（安全和速度的保证）</li>
<li>支持区分国内外流量（PAC模式）</li>
<li>可对应用设置单独代理</li>
</ul>
<p>安装和配置主要是参考秋水逸冰文章：</p>
<ol>
<li><p>在VPS上安装SS前，需要先安装最新内核并开启 BBR，可以使用秋水逸冰的一键安装脚本，具体<a href="https://teddysun.com/489.html" rel="external nofollow noopener noreferrer" target="_blank">看这里</a>。<br>BBR 即拥塞控制算法，目的是要尽量跑满带宽, 并且尽量不要有排队的情况, 效果并不比速锐差。据很多人反馈，速度比锐速还厉害！！</p>
</li>
<li><p>SS的安装和配置具体也可见秋水逸冰<a href="https://teddysun.com/486.html/comment-page-6" rel="external nofollow noopener noreferrer" target="_blank">一键安装脚本</a>。一般选择Python版。</p>
</li>
<li><p>最后在Win、Mac、IOS、android中下载对应的SS客户端，填入以上配置好的IP、端口、密码，选择相应的加密方式(Win下，右键任务栏纸飞机小图标，启用系统代理)，即可去探索外面的世界了。</p>
</li>
</ol>
]]></content>
      
        
        <tags>
            
            <tag> VPS </tag>
            
            <tag> SS </tag>
            
            <tag> 科学上网 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用Valine插件为Hexo博客添加评论功能]]></title>
      <url>/2017/11/21/valine.html</url>
      <content type="html"><![CDATA[<p>Hexo由于其静态特性，具有一定的局限性，因此需要借助于第三方服务来扩展站点的功能。作为一个博客系统，Hexo几乎完美，唯独差了一个最重要的互动功能——访客评论。NexT主题内置了多款第三方评论系统：多说、畅言、有言、disqus、gitment等等，试用过后都觉得差强人意。不经意间发现了Valine，部署简单，界面风格简洁，调用迅速(无后端)，还支持Markdown，这简直就是Hexo的绝配。<br><a id="more"></a></p>
<p>至于放弃其他几个系统，主要原因有以下：</p>
<ul>
<li>多说 - 这个不必多说，已经关闭；</li>
<li>畅言 - 搜狐旗下，应该不错，不过域名需要备案才可以使用，是一个不小的门槛；</li>
<li>有言 - jiaThis旗下，使用过程中遇到多次无法在页面中正常加载的情况，不稳定；</li>
<li>disqus和gitment - 一句话，远在大洋彼岸不适合国内使用。</li>
</ul>
<hr>
<h1 id="Valine简介"><a href="#Valine简介" class="headerlink" title="Valine简介"></a>Valine简介</h1><p> <strong>Valine</strong>(<a href="https://valine.js.org" rel="external nofollow noopener noreferrer" target="_blank">官网</a>)是一款基于<a href="http://leancloud.cn/" rel="external nofollow noopener noreferrer" target="_blank">Leancloud</a>的快速、简洁且高效的无后端评论系统。</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul>
<li>快速</li>
<li>安全</li>
<li>无后端实现</li>
<li>MarkDown 全语法支持</li>
<li>轻量易用(~15kb gzipped)</li>
</ul>
<h1 id="Valine配置及使用"><a href="#Valine配置及使用" class="headerlink" title="Valine配置及使用"></a>Valine配置及使用</h1><h2 id="获取appid和appkey"><a href="#获取appid和appkey" class="headerlink" title="获取appid和appkey"></a>获取appid和appkey</h2><p>请先<a href="https://leancloud.cn/dashboard/login.html#/signin" rel="external nofollow noopener noreferrer" target="_blank">登录</a>或<a href="https://leancloud.cn/dashboard/login.html#/signup" rel="external nofollow noopener noreferrer" target="_blank">注册</a> <code>LeanCloud</code>, 进入<a href="https://leancloud.cn/dashboard/applist.html#/apps" rel="external nofollow noopener noreferrer" target="_blank">控制台</a>后点击左下角<a href="https://leancloud.cn/dashboard/applist.html#/newapp" rel="external nofollow noopener noreferrer" target="_blank">创建应用</a>，选择免费的开发版即可。注意右上角有几个节点，可以就近选择。<br><img src="https://cdn.shup.cn//valine/create.png" width="400" height="300"><br>应用创建好以后，进入刚刚创建的应用，选择左下角的<code>设置</code>&gt;<code>应用Key</code>，然后就能看到你的<code>appid</code>和<code>appkey</code>了：<br><img src="https://cdn.shup.cn//valine/IDnKey.png" width="400" height="300"><br>为了数据安全，请注意设置自己的<code>安全域名</code>：<br><img src="https://cdn.shup.cn//valine/securedn.png" width="400" height="300"></p>
<h2 id="Hexo-NexT中的开启和设置"><a href="#Hexo-NexT中的开启和设置" class="headerlink" title="Hexo-NexT中的开启和设置"></a>Hexo-NexT中的开启和设置</h2><p>Hexo-NexT中已经默认安装了Valine插件，如果没有可以使用以下命令安装：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span> valine <span class="comment">--save</span></span><br></pre></td></tr></table></figure>
<p>完成后，在NexT主题配置文件中加入/修改代码以开启：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Valine.</span></span><br><span class="line"><span class="comment"># You can get your appid and appkey from https://leancloud.cn</span></span><br><span class="line"><span class="comment"># more info please open https://valine.js.org</span></span><br><span class="line"><span class="attr">valine:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span> <span class="comment"># 是否开启</span></span><br><span class="line"><span class="attr">  appid:</span>                            <span class="comment"># 填上之前获取的AppID</span></span><br><span class="line"><span class="attr">  appkey:</span>                           <span class="comment"># 填上之前获取的AppKey</span></span><br><span class="line"><span class="attr">  notify:</span> <span class="literal">false</span> <span class="comment"># 新留言是否需要通知 https://github.com/xCss/Valine/wiki</span></span><br><span class="line"><span class="attr">  verify:</span> <span class="literal">false</span> <span class="comment"># 是否需要验证，验证比较反人类建议false关闭</span></span><br><span class="line"><span class="attr">  placeholder:</span> <span class="string">请在此输入您的留言</span> <span class="comment"># 默认留言框内的文字</span></span><br><span class="line"><span class="attr">  avatar:</span> <span class="string">mm</span> <span class="comment"># 默认头像</span></span><br><span class="line"><span class="attr">  guest_info:</span> <span class="string">nick,mail</span> <span class="comment"># 默认留言框的头部需要访问者输入的信息</span></span><br><span class="line"><span class="attr">  pageSize:</span> <span class="number">10</span> <span class="comment"># pagination size #默认单页的留言条数</span></span><br></pre></td></tr></table></figure>
<p>OK，至此已经已经完成配置并成功开启，<code>Hexo g -d</code>赶紧去看效果吧。</p>
<p>后期如果需要管理留言，至<code>leancloud/控制台/储存/comment</code>即可进行添加、删除等操作。</p>
]]></content>
      
        
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Valine </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[用又拍云CDN加速Hexo博客]]></title>
      <url>/2017/11/21/cdn.html</url>
      <content type="html"><![CDATA[<p>辛辛苦苦搭建好博客，虽然Hexo本身是全静态网页，页面加载速度相对于动态博客程序已经是非常可观，但NexT主题调用了不少js文件，如果再加上其他的图片、音视频插件等等还是会在一定程度上造成延迟。本着折腾不止和完美主义的精神，用CDN来加速Hexo！<br><a id="more"></a></p>
<h1 id="CDN加速的原理"><a href="#CDN加速的原理" class="headerlink" title="CDN加速的原理"></a>CDN加速的原理</h1><p>这里简明扼要地解释一下CDN加速的原理：你上传到CDN加速网站(如<strong>又拍</strong>或者<strong>七牛</strong>)空间里的文件(或者网站)以镜像的形式存放到多台服务器，这些服务器分布在祖国甚至全世界各地，访问者就近读取较快的镜像，以实现快速加载的效果。举个栗子：你的文件(或网站)在上海，没有CDN，一个北京的访问者需要直接连接你在上海的服务器，有了CDN，这个北京的访问者只需要访问你的文件(网站)在北京的镜像即可。尤其是国内外的互访，CDN可使访问速度大大提升。</p>
<h1 id="哪些因素会影响加载速度？"><a href="#哪些因素会影响加载速度？" class="headerlink" title="哪些因素会影响加载速度？"></a>哪些因素会影响加载速度？</h1><h2 id="js文件"><a href="#js文件" class="headerlink" title="js文件"></a>js文件</h2><p>js文件就是JavaScript脚本文件，用来实现各种酷炫的动态效果。一般是加载在html页面的<code>&lt;head&gt;</code>部分，所以页面加载速度首先要考虑这一块。Hexo的js文件大致包含以下3类：</p>
<ol>
<li>公共js<br>公共js是通用型，比如实现图片放大效果的<strong>Fancybox</strong>，或者实现图片慢加载的<strong>LazyLoad</strong>等等。这些js已经开发好，直接在html里引用(存放在镜像网站上，如<a href="http://www.bootcdn.cn/" rel="external nofollow noopener noreferrer" target="_blank">BootCDN</a>)js文件链接即可实现效果。</li>
<li>定制页面效果js<br>即NexT主题中定制的某些特效，例如实现页面响应式效果的<strong>Bootstrap</strong>，或者增强移动端滚动及动画效果的<strong>Motion</strong>等等。这些js理论上也是公共js，只不过NexT主题作者修改了代码，以适用于NexT主题。这些js文件存放在本地Hexo目录<code>hexo\themes\next\source\js\src</code>下。</li>
<li>第三方插件js<br>这个不用多说了吧，Hexo默认安装了不少实用的第三方插件，比如，可直接在网页中显示数学公式的<strong>MathJax</strong>，优化SEO的<strong>Baidu-push</strong>等等。这些插件可在<strong>主题</strong>配置文件<code>_config.yml</code>中进行配置。相关js文件有些存放在<code>hexo\themes\next\layout\_third-party</code>中，有些则通过外部引用形式加载。<h2 id="图片-音、视频"><a href="#图片-音、视频" class="headerlink" title="图片(音、视频)"></a>图片(音、视频)</h2>如果博客文章很多，绝大部分的带宽都会消耗在这部分静态数据上。这个不多说了。<h2 id="Google字体引用"><a href="#Google字体引用" class="headerlink" title="Google字体引用"></a>Google字体引用</h2>很多文章中提到，由于被墙的缘故，引用Google字体会严重拖累网站，于是乎屏蔽Google字体的插件层出不穷。不过笔者测试发现，无论是Google字体<a href="http://www.googlefonts.cn" rel="external nofollow noopener noreferrer" target="_blank">中文官网</a>，还是Google字体的引用服务器<code>fonts.googleapis.com</code>都没有被墙，而其速度在全球范围内都相当理想(如下图)，所以完全没有必要修改Google字体的引用源，比如改成360CDN什么的。<img src="https://cdn.shup.cn/cdn/google-font-test.png" width="400" height="300">
综上，下面就开始着手对Hexo博客的<strong>js文件</strong>和<strong>图片(音、视频)</strong>文件进行CDN加速。</li>
</ol>
<h1 id="CDN加速"><a href="#CDN加速" class="headerlink" title="CDN加速"></a>CDN加速</h1><h2 id="公共js加速"><a href="#公共js加速" class="headerlink" title="公共js加速"></a>公共js加速</h2><p>在版本 5.0.1 之后的NexT主题，有一个方便的功能可以通过修改<strong>主题</strong>配置文件<code>_config.yml</code>中常用外部js的引用地址，来实现自定义CDN加速。下面是此部分的配置(在<code>_config.yml</code>搜索<code>CDN</code>即可找到)，笔者已经修改成BootCDN的引用地址。关于国内靠谱的JavaScript CDN库，还是推荐BootCDN，可参考知乎的<a href="https://www.zhihu.com/question/20227463" rel="external nofollow noopener noreferrer" target="_blank">讨论</a>。</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"># <span class="selector-tag">Script</span> <span class="selector-tag">Vendors</span>.</span><br><span class="line"># <span class="selector-tag">Set</span> <span class="selector-tag">a</span> <span class="selector-tag">CDN</span> <span class="selector-tag">address</span> <span class="selector-tag">for</span> <span class="selector-tag">the</span> <span class="selector-tag">vendor</span> <span class="selector-tag">you</span> <span class="selector-tag">want</span> <span class="selector-tag">to</span> <span class="selector-tag">customize</span>.</span><br><span class="line"># <span class="selector-tag">For</span> <span class="selector-tag">example</span></span><br><span class="line">#    <span class="selector-tag">jquery</span>: <span class="selector-tag">https</span>:<span class="comment">//ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js</span></span><br><span class="line"># <span class="selector-tag">Be</span> <span class="selector-tag">aware</span> <span class="selector-tag">that</span> <span class="selector-tag">you</span> <span class="selector-tag">should</span> <span class="selector-tag">use</span> <span class="selector-tag">the</span> <span class="selector-tag">same</span> <span class="selector-tag">version</span> <span class="selector-tag">as</span> <span class="selector-tag">internal</span> <span class="selector-tag">ones</span> <span class="selector-tag">to</span> <span class="selector-tag">avoid</span> <span class="selector-tag">potential</span> <span class="selector-tag">problems</span>.</span><br><span class="line"># <span class="selector-tag">Please</span> <span class="selector-tag">use</span> <span class="selector-tag">the</span> <span class="selector-tag">https</span> <span class="selector-tag">protocol</span> <span class="selector-tag">of</span> <span class="selector-tag">CDN</span> <span class="selector-tag">files</span> <span class="keyword">when</span> you enable https on your site.</span><br><span class="line"><span class="attribute">vendors</span>:</span><br><span class="line">  # Internal path prefix. Please do <span class="keyword">not</span> edit it.</span><br><span class="line">  <span class="attribute">_internal</span>: lib</span><br><span class="line"></span><br><span class="line">  # Internal <span class="attribute">version</span>: <span class="number">2.1</span>.<span class="number">3</span></span><br><span class="line">  <span class="attribute">jquery</span>: <span class="attribute">https</span>:<span class="comment">//cdn.bootcss.com/jquery/2.1.3/jquery.min.js</span></span><br><span class="line"></span><br><span class="line">  # Internal <span class="attribute">version</span>: <span class="number">2.1</span>.<span class="number">5</span></span><br><span class="line">  # <span class="attribute">See</span>: <span class="attribute">http</span>:<span class="comment">//fancyapps.com/fancybox/</span></span><br><span class="line">  <span class="attribute">fancybox</span>: <span class="attribute">https</span>:<span class="comment">//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js</span></span><br><span class="line">  <span class="attribute">fancybox_css</span>: <span class="attribute">https</span>:<span class="comment">//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css</span></span><br><span class="line"></span><br><span class="line">  # Internal <span class="attribute">version</span>: <span class="number">1.0</span>.<span class="number">6</span></span><br><span class="line">  # <span class="attribute">See</span>: <span class="attribute">https</span>:<span class="comment">//github.com/ftlabs/fastclick</span></span><br><span class="line">  <span class="attribute">fastclick</span>: <span class="attribute">https</span>:<span class="comment">//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js</span></span><br><span class="line"></span><br><span class="line">  # Internal <span class="attribute">version</span>: <span class="number">1.9</span>.<span class="number">7</span></span><br><span class="line">  # <span class="attribute">See</span>: <span class="attribute">https</span>:<span class="comment">//github.com/tuupola/jquery_lazyload</span></span><br><span class="line">  <span class="attribute">lazyload</span>: <span class="attribute">https</span>:<span class="comment">//cdn.bootcss.com/jquery_lazyload/1.9.7/jquery.lazyload.min.js</span></span><br><span class="line"></span><br><span class="line">  # Internal <span class="attribute">version</span>: <span class="number">1.2</span>.<span class="number">1</span></span><br><span class="line">  # <span class="attribute">See</span>: <span class="attribute">http</span>:<span class="comment">//VelocityJS.org</span></span><br><span class="line">  <span class="attribute">velocity</span>: <span class="attribute">https</span>:<span class="comment">//cdn.bootcss.com/velocity/1.2.1/velocity.min.js</span></span><br><span class="line"></span><br><span class="line">  # Internal <span class="attribute">version</span>: <span class="number">1.2</span>.<span class="number">1</span></span><br><span class="line">  # <span class="attribute">See</span>: <span class="attribute">http</span>:<span class="comment">//VelocityJS.org</span></span><br><span class="line">  <span class="attribute">velocity_ui</span>: <span class="attribute">https</span>:<span class="comment">//cdn.bootcss.com/velocity/1.2.1/velocity.ui.min.js</span></span><br><span class="line"></span><br><span class="line">  # Internal <span class="attribute">version</span>: <span class="number">0.7</span>.<span class="number">9</span></span><br><span class="line">  # <span class="attribute">See</span>: <span class="attribute">https</span>:<span class="comment">//faisalman.github.io/ua-parser-js/</span></span><br><span class="line">  <span class="attribute">ua_parser</span>: <span class="attribute">https</span>:<span class="comment">//cdn.bootcss.com/UAParser.js/0.7.9/ua-parser.min.js</span></span><br><span class="line"></span><br><span class="line">  # Internal <span class="attribute">version</span>: <span class="number">4.6</span>.<span class="number">2</span></span><br><span class="line">  # <span class="attribute">See</span>: <span class="attribute">http</span>:<span class="comment">//fontawesome.io/</span></span><br><span class="line">  <span class="attribute">fontawesome</span>: <span class="attribute">https</span>:<span class="comment">//cdn.bootcss.com/font-awesome/4.6.2/css/font-awesome.min.css</span></span><br><span class="line"></span><br><span class="line">  # Internal <span class="attribute">version</span>: <span class="number">1</span></span><br><span class="line">  # <span class="attribute">https</span>:<span class="comment">//www.algolia.com</span></span><br><span class="line">  <span class="attribute">algolia_instant_js</span>: </span><br><span class="line">  <span class="attribute">algolia_instant_css</span>:</span><br><span class="line"></span><br><span class="line">  # Internal <span class="attribute">version</span>: <span class="number">1.0</span>.<span class="number">2</span></span><br><span class="line">  # <span class="attribute">See</span>: <span class="attribute">https</span>:<span class="comment">//github.com/HubSpot/pace</span></span><br><span class="line">  # Or use direct links <span class="attribute">below</span>:</span><br><span class="line">  # <span class="attribute">pace</span>: <span class="comment">//cdn.bootcss.com/pace/1.0.2/pace.min.js</span></span><br><span class="line">  # <span class="attribute">pace_css</span>: <span class="comment">//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-flash.min.css</span></span><br><span class="line">  <span class="attribute">pace</span>: <span class="attribute">https</span>:<span class="comment">//cdn.bootcss.com/pace/1.0.2/pace.js</span></span><br><span class="line">  <span class="attribute">pace_css</span>: <span class="attribute">https</span>:<span class="comment">//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-flash.min.css</span></span><br></pre></td></tr></table></figure>
<p>使用Chrome浏览器开发者工具-&gt;Network，按住Shift+刷新(全新加载)即可看到效果。下图显示加速的效果非常好！修改前首页加载需要10秒以上，其中尤其index.js(即JQuery.js)严重拖累了加载速度。修改之后，基本上就是——<strong>秒开！</strong><br><img src="https://cdn.shup.cn/cdn/comparison.png" width="400" height="300"></p>
<h2 id="页面效果js加速"><a href="#页面效果js加速" class="headerlink" title="页面效果js加速"></a>页面效果js加速</h2><p>这些js文件存放在本地，原则上把它们上传到CDN加速空间中，再修改引用源即可。但基于以下原因考虑，这里不做修改。</p>
<ul>
<li>这些js文件对加载速度影响不大；</li>
<li>如果主题更新又会恢复到原始状态；</li>
<li>修改引用源改动源文件较多、比较麻烦。</li>
</ul>
<h2 id="插件js加速"><a href="#插件js加速" class="headerlink" title="插件js加速"></a>插件js加速</h2><p>同样道理，这些js文件若是存放在Hexo本地的，需要将他们上传到CDN加速空间里；如果是外部引用，需要先将引用地址的原js文件下载下来，存放到CDN加速空间里。最后统一修改原引用地址到CDN加速空间地址。</p>
<p>下面以<strong>又拍云</strong>的CDN为例介绍，注册开通很简单，这里略过。需要注意不管七牛还是又拍，注册时都需要上传手持身份证的照片进行身份核验。身份认证后即可开始操作，具体操作方法请参考官方<a href="https://docs.upyun.com/api/quick_start/" rel="external nofollow noopener noreferrer" target="_blank">文档</a>。简单说两句：创建的服务选择网页图片类型，然后添加操作员、密码即可，后面如有需要还可以绑定域名(需备案)，https等等。</p>
<p>一切就绪后，下面以加速<code>valine.js</code>插件为例说明。<strong>Valine</strong>是一款评论插件，安装及配置请参考<a href="https://shup.cn/2017/11/21/valine.html">《使用Valine插件为Hexo博客添加评论功能》</a>。</p>
<p>开启并配置好Valine后，打开<code>hexo\themes\next\layout\_third-party\comments\valine.js</code>可以看到如下代码：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//cdn1.lncld.net/static/js/3.0.4/av-min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">'//unpkg.com/valine/dist/Valine.min.js'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以看出<strong>Valine</strong>的运行是依赖以上2个外部js文件，这里以加速第二个js文件为例，修改第二个js文件的源为：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//XXX.test.upcdn.net/Valine.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> # XXX改成你的又拍云服务名</span><br></pre></td></tr></table></figure>
<p>然后，把<strong>原js文件</strong><code>Valine.min.js</code>、即<code>https://unpkg.com/valine/dist/Valine.min.js</code>下载下来，通过FTP工具(推荐<code>FileZilla</code>)上传到你的又拍云空间根目录里。</p>
<p>这样，<code>Valine.min.js</code>这个文件就在用又拍云进行CDN加速了。<code>Hexo g -d</code>查看效果吧。其他插件js的加速理论上适用上述方法，关键是第一步要找到js文件正真的源引用地址。</p>
<h2 id="图片-音、视频-加速"><a href="#图片-音、视频-加速" class="headerlink" title="图片(音、视频)加速"></a>图片(音、视频)加速</h2><p>其实如果以上的操作没有问题，图片(音、视频)的CDN加速也是同样的方法。</p>
<p>比如，你的文章里有本来有一张图片，图片地址为<code>http://xxx.com/123.jpg</code>。把这个图片上传到你的又拍云空间里，即可获得地址：<code>http://xxx.test.upcdn.net/123.jpg</code>，将此地址插入到文章中即可实现图片的CDN加速。而且后期还可以利用又拍云的云处理功能对图片增加缩略图、水印、防盗链，对音视频转解码，压缩等等。</p>
<p>如果你理解以上的原理，可以将其他任何类型(一般加速图片，音频，视频，js，css等)的静态文件的转移到CDN上，从而将你的网站优化的更好。</p>
]]></content>
      
        
        <tags>
            
            <tag> CDN </tag>
            
            <tag> Hexo </tag>
            
            <tag> 又拍云 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[在阿里云VPS上部署Hexo]]></title>
      <url>/2017/11/16/hexo.html</url>
      <content type="html"><![CDATA[<p>自双11购入了阿里云的VPS后，一直想着捯饬些什么，首当其冲的就是搭一个博客站点。之前使用过WordPress、Joomla、Drupal、国人的Typecho、Emlog、Zblog等。前几个国外的博客虽然功能、插件、模版丰富，但感觉略显臃肿，过多冗余之处，不适合做个人站点使用，尤其不适合笔者的1G1M的小水管主机。而国人的Typecho、Emlog感觉不错，安装使用简单、占用内存少、界面清新，没有多余的功能，支持Markdown，还原写作本质。但在使用中，出现不少小问题，细节不完善，影响实际体验，遂弃之。直到遇见了<strong>Hexo</strong>……<br><a id="more"></a></p>
<p>Hexo的介绍不再赘述，可以登录其<a href="https://hexo.io/zh-cn/" rel="external nofollow noopener noreferrer" target="_blank">中文官网</a>了解。其实在接触Hexo之前，笔者就对纯静态的博客框架有所了解，比如jekyll、octopress等。与Hexo一样，他们的共同的优点就是部署页面纯静态html，加载速度快、浏览体验好、占用内存小，支持Markdown，当然最重要的一点是<strong>有逼格</strong>。最终放弃Jekyll等等选择Hexo的原因是：相对于Jekyll基于Ruby实现，Hexo基于Node.js，在Windows上安装Node.js环境更简单，另外，Hexo的主题更符合我的品位。</p>
<p>这类静态博客系统最大的一个缺陷就在于要求用户具有一定的技术水平，Hexo是我见过最难建立的博客系统。网上有很多文章是把Hexo部署到Github或者Coding等，优点是搭建快捷、免费，缺点显而易见，Github远在大洋彼岸，加载速度可想而知，而Coding则是有广告。既然已经有了云主机，当然不能浪费。笔者阅读了网上N多文章及教程，踩过坑，走过弯路，在经历N次的失败后，终于搭建成功。下面就把最简明扼要的过程列出来，谨以此自勉或造福后人。</p>
<hr>
<h1 id="准备条件"><a href="#准备条件" class="headerlink" title="准备条件"></a>准备条件</h1><h2 id="VPS及域名"><a href="#VPS及域名" class="headerlink" title="VPS及域名"></a>VPS及域名</h2><p>笔者购买的是阿里云的轻量云服务器，1核1G1M20GSSD，CentOS 7.4系统，搭配<a href="https://www.bt.cn" rel="external nofollow noopener noreferrer" target="_blank">宝塔面板</a>(方便可视化操作)，本文操作过程理论上适用于其他Linux系统。域名需添加A解析记录指向主机IP，域名购买、解析(国内VPS需备案)的过程请自行搜索。</p>
<h2 id="SSH工具"><a href="#SSH工具" class="headerlink" title="SSH工具"></a>SSH工具</h2><p>SSH工具是我们用来以命令行的方式远程操作服务器端。Putty小巧、免费，Xshell功能更强大，但是收费。笔者使用的是Putty，点此下载<a href="https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html" rel="external nofollow noopener noreferrer" target="_blank">(最新版)</a>，注意本地操作系统，自行下载相应版本安装。如何使用SSH工具连接VPS，请看阿里云的<a href="https://help.aliyun.com/document_detail/59083.html#windows" rel="external nofollow noopener noreferrer" target="_blank">官方教程</a>。</p>
<h1 id="本地端配置"><a href="#本地端配置" class="headerlink" title="本地端配置"></a>本地端配置</h1><p>本地配置很简单，依次安装好Node.js和Git,再安装Hexo即可，Hexo需要前两者的支持。本人是用的win10系统，本地端不需要什么配置，只要安装相应版本即可，Mac或Linux系统应该更容易。</p>
<h2 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h2><p>这里给出Node.js官方下载链接：<a href="https://nodejs.org/zh-cn/download/" rel="external nofollow noopener noreferrer" target="_blank">https://nodejs.org/zh-cn/download/</a><br>安装没什么好说的，一路默认下一步即可。</p>
<h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><p>同样给出Git官方下载链接：<a href="https://git-scm.com/downloads" rel="external nofollow noopener noreferrer" target="_blank">https://git-scm.com/downloads</a><br>对应自己的本地系统下载即可，这个套件不仅仅在windows上安装了Git版本控制系统，最重要的是这个套件提供了Git Bash，一个可以在windows上运行的Linux风格shell，除非你够硬核，能忍受win的cmd，否则通过Git Bash使用hexo无疑是最佳选择。下图的选项建议勾选，视觉效果有明显提升。其余选项保持默认即可。<br><img src="https://cdn.shup.cn/hexo/git.png" width="400" height="300"></p>
<h2 id="安装并熟悉Hexo"><a href="#安装并熟悉Hexo" class="headerlink" title="安装并熟悉Hexo"></a>安装并熟悉Hexo</h2><p>Hexo最好的教程当然是<a href="https://hexo.io/zh-cn/docs/index.html" rel="external nofollow noopener noreferrer" target="_blank">官方文档</a>！先不用花时间全看完官方文档，这里稍微说下要点，部署好之后可以仔细研究官方文档。</p>
<p>首先是安装，在Git Bash下输入这条命令就安装Hexo了，简单吧。不过这仅仅是把Hexo的程序写进了系统，网站还没有部署好。</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-<span class="keyword">cli</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>注意：</strong><code>npm</code>在国内被墙了，国内用户需要挂代理，否则输入命令后半天没反应。这里推荐一个最好的办法。每次要用<code>npm</code>命令时，先输入以下命令行。</li>
</ul>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">npm config <span class="keyword">set</span> registry <span class="comment">https:</span>//<span class="comment">registry.npm.taobao.org</span></span><br></pre></td></tr></table></figure>
<p>接下来熟悉怎么使用Hexo</p>
<ol>
<li><p>首先建立一个站点</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">hexo init <span class="params">&lt;folder&gt;</span>	<span class="comment">//以folder为目录名建立站点文件夹</span></span><br><span class="line">cd <span class="params">&lt;folder&gt;</span>	<span class="comment">//转移到站点目录</span></span><br><span class="line">npm install	<span class="comment">//安装依赖</span></span><br></pre></td></tr></table></figure>
<p>一个网站对应着一个站点文件夹，这里就是你的整个Hexo博客网站。之后的操作我们都在该站点目录下进行。</p>
<p>以上，也可以先新建一个文件夹，直接右键Git Bash Here。然后<code>hexo init</code>即可。</p>
</li>
<li><p>新建一篇文章</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> &lt;<span class="built_in">title</span>&gt;</span><br></pre></td></tr></table></figure>
<p>新建立的文章是markdown（以下简称md）文件，熟悉mac的一定知道吧，不熟悉的几分钟就能上手。我们编辑博客就是用编辑md文件实现的。在<code>source/_post</code>目录下，我们看到里面已经有个<code>hello-world.md</code>了。</p>
</li>
<li><p>编辑文章<br>就是编辑你新建的md文件啦。这就需要markdown编辑器喽，当然mac就省事了，对于win系统，Typora和MarkdownPad编辑器，看个人喜好选择。</p>
</li>
<li><p>启动本地服务器</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hexo s</span></span><br></pre></td></tr></table></figure>
<p>这条命令会在本地启动服务器，访问地址为<code>localhost:4000</code>，主要是我们正式发布前预览测试用的，启动后你编辑文章和主题等都可以直接更新到该网址，非常方便！但是注意，编辑站点配置文件<code>_config.yml</code>是需要重启该服务器才生效的。现在我们就看下自带<code>hello-world.md</code>的预览效果吧。还是蛮酷炫的吧！</p>
<img src="https://cdn.shup.cn/hexo/hello.png" width="400" height="300"> 
<p>这里有个坑吐槽一下，若Win安装了福某PDF阅读器会占用4000端口，需要用<code>hexo s -p 5000</code>命令把端口换成5000来执行启动。</p>
</li>
<li><p>生成静态文件</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hexo g</span></span><br></pre></td></tr></table></figure>
<p>这条命令是由各种md文件和资源生成可部署的静态html页面等，生成的资源都放在新生成的<code>public</code>目录下。</p>
</li>
<li><p>部署到服务器</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hexo d</span></span><br></pre></td></tr></table></figure>
<p>部署方式有多种，对这篇文章来说，就是利用Git部署到你的VPS服务器了，当然在这输入是没卵用的~还没配置服务器端。</p>
</li>
</ol>
<p>掌握以上命令基本就OK了，还有一条<code>hexo clean</code>用来清理缓存，其他的一般用不到，有兴趣的再看<a href="https://hexo.io/zh-cn/docs/index.html" rel="external nofollow noopener noreferrer" target="_blank">官方文档</a>。接下来我们看VPS服务器端配置。</p>
<h1 id="VPS服务器端配置"><a href="#VPS服务器端配置" class="headerlink" title="VPS服务器端配置"></a>VPS服务器端配置</h1><p>这一部分的配置就用之前说的Xshell或putty来搞定！</p>
<h2 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h2><p>创建用户用于服务器端站点管理，如下：</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">adduser hexo	<span class="comment">//创建用户</span></span><br><span class="line">passwd hexo	<span class="comment">//设置密码</span></span><br><span class="line"><span class="keyword">su</span>	<span class="comment">//检查是否有安装sudo</span></span><br></pre></td></tr></table></figure>
<p>有的linux系统初始没安装<code>sudo</code>，为了方便，我们需要安装<code>sudo</code>，已有安装的话，跳过这步。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">yum <span class="keyword">install</span> sudo</span><br></pre></td></tr></table></figure>
<p>再次，为了方便，赋予hexo用户root权限，使用vi命令在<code>/etc/sudoers</code>中添加一行。不会vim编辑临时搜一下，简单，当然也可以通过<strong>宝塔面板</strong>进行可视化操作。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">vi <span class="regexp">/etc/</span>sudoers</span><br></pre></td></tr></table></figure>
<p>找到这一行添加：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">root        <span class="keyword">ALL</span>=(<span class="keyword">ALL</span>)       <span class="keyword">ALL</span></span><br><span class="line">hexo        <span class="keyword">ALL</span>=(<span class="keyword">ALL</span>)       <span class="keyword">ALL</span> #这个是添加的</span><br></pre></td></tr></table></figure>
<h2 id="配置本地端无密码ssh登录服务端"><a href="#配置本地端无密码ssh登录服务端" class="headerlink" title="配置本地端无密码ssh登录服务端"></a>配置本地端无密码ssh登录服务端</h2><p>这里为什么要用到Git呢？因为这里的Hexo发布博客是用Git来部署的，而Git又是基于ssh连接的，所以实现一键发布博客就得配置这玩意了。其实很简单，有的教程复杂化了，注意这里最后一步是在本地端操作。</p>
<ol>
<li><p><strong>服务器端</strong>生成ssh密钥</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">su hexo</span><br><span class="line"><span class="keyword">cd</span> <span class="string">/home/hexo</span></span><br><span class="line">mkdir <span class="string">.ssh</span></span><br><span class="line"><span class="keyword">cd</span> <span class="string">.ssh</span></span><br><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>
<p>在生成密钥时，会要求你输入一个加密密码，可以不填写(一路回车)，实现无密码登陆。完成后会在<code>/home/hexo/.ssh/</code>文件夹下生成2个key，一个公钥<code>id_rsa.pub</code>，一个私钥<code>id_rsa</code>，编辑此文件夹中的<code>authorized_keys</code>文件(如没有则新建一个)，把公钥里面的内容全部复制粘贴进去(包含公钥开头的ssh-rsa)。然后把公钥和私钥2个文件下载到本地，后面会用到。</p>
</li>
<li><p><strong>服务器端</strong>确保配置及权限正确(这一步仅为确保，可暂时忽略，若后面ssh连接不成功可返回此步骤检查)</p>
<p>查看<code>/etc/ssh/sshd_config</code>文件配置是否如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">HostKey</span> <span class="string">/etc/ssh/ssh_host_rsa_key</span></span><br><span class="line"><span class="string">RSAAuthentication</span> <span class="literal">yes</span> </span><br><span class="line"><span class="string">PubkeyAuthentication</span> <span class="literal">yes</span></span><br><span class="line"><span class="string">AuthorizedKeysFile</span>      <span class="string">.ssh/authorized_keys</span></span><br></pre></td></tr></table></figure>
<p>确保用户<code>hexo</code>及<code>.ssh</code>文件夹及相关密钥文件权限正确</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">chown -R <span class="string">hexo:</span>hexo <span class="regexp">/home/</span>hexo</span><br><span class="line">chmod <span class="number">700</span> <span class="regexp">/home/</span>hexo</span><br><span class="line">chmod <span class="number">700</span> <span class="regexp">/home/</span>hexo/.ssh</span><br><span class="line">chmod <span class="number">644</span> <span class="regexp">/home/</span>hexo<span class="regexp">/.ssh/</span>authorized_keys  <span class="comment">//公钥文件的所有权限</span></span><br><span class="line">chmod <span class="number">600</span> <span class="regexp">/home/</span>hexo<span class="regexp">/.ssh/</span>id_rsa        <span class="comment">//私钥文件的所有权限</span></span><br></pre></td></tr></table></figure>
<p>查看是否有安装ssh并安装，没有的话使用yum安装</p>
 <img src="https://cdn.shup.cn/hexo/ssh1.png" width="400" height="300">
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">rpm -qa |<span class="keyword">grep</span> ssh <span class="comment">//检查是否有ssh</span></span><br><span class="line">yum install ssh <span class="comment">//如果没有ssh运行，则执行此命令安装ssh</span></span><br></pre></td></tr></table></figure>
<p>安装完后启动服务</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">service sshd <span class="built_in">start</span></span><br><span class="line">service sshd status<span class="comment"> //检查是否已启动，看到running即可</span></span><br></pre></td></tr></table></figure>
<img src="https://cdn.shup.cn/hexo/ssh-run.png" width="400" height="300"></li>
<li><p><strong>本地端</strong>ssh配置 </p>
<p>打开Git Bash，输入<code>pwd</code>查看本地用户的文件夹地址，如下图，一般默认在<code>C:\User\你的账户名</code>。然后打开用户文件夹里的<code>.ssh</code>文件夹，把刚刚从服务器上下载到本地的两个密钥文件拷贝进去。</p>
<img src="https://cdn.shup.cn/hexo/pwd.png" width="400" height="300"></li>
<li><p><strong>本地端</strong>ssh验证</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">ssh hexo<span class="meta">@你的域名或者IP</span> //<span class="meta">@前是你创建的站点管理用户</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>OK，无密码ssh登陆完成，配置过程注意是在本地端还是服务器端操作。如果连接不成功，返回上述第2步检查。</p>
<h2 id="安装配置nginx"><a href="#安装配置nginx" class="headerlink" title="安装配置nginx"></a>安装配置nginx</h2><p>简单来说，nginx是代理服务器，有它我们就能按照域名或IP访问网页了。</p>
<ol>
<li><p>添加nginx源，安装nginx<br>在<code>/etc/yum.repos.d</code>目录下创建一个yum源文件<code>nginx.repo</code>,用vi编辑或用宝塔写入如下内容。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[nginx]</span></span><br><span class="line"><span class="attr">name</span>=nginx repo</span><br><span class="line"><span class="attr">baseurl</span>=http://nginx.org/packages/centos/<span class="variable">$releasever</span>/<span class="variable">$basearch</span>/</span><br><span class="line"><span class="attr">gpgcheck</span>=<span class="number">0</span></span><br><span class="line"><span class="attr">enabled</span>=<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>安装nginx(宝塔里面也有一键安装nginx，不过这种方式更简单)</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">yum install nginx -<span class="built_in">y</span></span><br><span class="line">nginx -v <span class="comment">//查看版本号验证</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>删除原配置文件</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">rm <span class="regexp">/etc/</span>nginx<span class="regexp">/conf.d/</span>*</span><br></pre></td></tr></table></figure>
<p>重新配置，添加以下内容到<code>/etc/nginx/conf.d/hexo.conf</code></p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">  <span class="attribute">root</span> /home/hexo/www;  <span class="comment">#网站根目录,用来存储网站文件，后面会创建</span></span><br><span class="line">  <span class="attribute">index</span> index.html index.htm;</span><br><span class="line">  <span class="attribute">server_name</span> www.shup.cn;   <span class="comment">#你的域名</span></span><br><span class="line">  <span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.html;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到没，这一步将你的域名和服务器下的网站根目录挂钩，主页是根目录下index.html<br><strong>很关键！！</strong></p>
</li>
<li><p>修改nginx配置文件<br>将<code>/etc/nginx/nginx.conf</code>中第一行的user值修改为hexo</p>
</li>
<li><p>切换到hexo用户，用户主目录下新建<code>www</code>文件夹作为网站根目录</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">su</span> hexo</span><br><span class="line"><span class="keyword">cd</span> ~</span><br><span class="line"><span class="keyword">mkdir</span> www</span><br></pre></td></tr></table></figure>
</li>
<li><p>验证配置是否正确，如下图。</p>
<img src="https://cdn.shup.cn/hexo/nginx.png" width="400" height="300"></li>
<li><p>启动nginx服务并测试</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">sudo service nginx start</span><br><span class="line">echo <span class="string">"hello nginx"</span> &gt; <span class="regexp">/home/</span>hexo<span class="regexp">/www/i</span>ndex.html	<span class="regexp">//</span>站点根目录下新建index.html</span><br></pre></td></tr></table></figure>
<p>在浏览器中输入你的<strong>域名</strong>或VPS的<strong>IP地址</strong>，出现<strong>hello nginx</strong>字样表示nginx代理服务器搭建成功！</p>
</li>
</ol>
<h2 id="安装配置Git"><a href="#安装配置Git" class="headerlink" title="安装配置Git"></a>安装配置Git</h2><p>即将完成任务~</p>
<ol>
<li><p>安装Git</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">sudo yum <span class="keyword">install</span> git</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化Git仓库<br>用户主目录下新建hexo.git文件夹用作Git仓库并初始化</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">cd ~</span><br><span class="line">mkdir hexo.git</span><br><span class="line">cd hexo.git</span><br><span class="line">git init --bare	<span class="comment">//初始化git仓库，bare表示空仓库</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置Git仓库的hooks</p>
<p>hooks，钩子，就是将不同目录的数据实现同步。具体如下，在Git仓库hooks目录下创建文件<code>post-receive</code>并修改权限</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cd</span> hooks</span><br><span class="line">touch <span class="keyword">post</span>-receive</span><br><span class="line">chmod 755 <span class="keyword">post</span>-receive</span><br></pre></td></tr></table></figure>
<p>将以下内容添加到<code>post-receive</code>中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">GIT_REPO=/home/hexo/hexo.git</span><br><span class="line">TMP_GIT_CLONE=/tmp/HexoBlog</span><br><span class="line">PUBLIC_WWW=/home/hexo/www</span><br><span class="line">rm -rf <span class="variable">$&#123;TMP_GIT_CLONE&#125;</span></span><br><span class="line">git <span class="built_in">clone</span> <span class="variable">$GIT_REPO</span> <span class="variable">$TMP_GIT_CLONE</span></span><br><span class="line">rm -rf <span class="variable">$&#123;PUBLIC_WWW&#125;</span>/*</span><br><span class="line">cp -rf <span class="variable">$&#123;TMP_GIT_CLONE&#125;</span>/* <span class="variable">$&#123;PUBLIC_WWW&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>至此，服务器端的配置全部完成。</p>
<h1 id="本地端部署验证"><a href="#本地端部署验证" class="headerlink" title="本地端部署验证"></a>本地端部署验证</h1><p>接下来我们就试试把博客发布到VPS服务器吧！下面都是<strong>本地端</strong>的操作。</p>
<h2 id="安装hexo-git部署模块"><a href="#安装hexo-git部署模块" class="headerlink" title="安装hexo git部署模块"></a>安装hexo git部署模块</h2><p>国内用户别忘记挂代理。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span> hexo-deployer-git <span class="comment">--save</span></span><br></pre></td></tr></table></figure>
<h2 id="修改站点配置文件-config-yml"><a href="#修改站点配置文件-config-yml" class="headerlink" title="修改站点配置文件_config.yml"></a>修改站点配置文件_config.yml</h2><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"># URL</span><br><span class="line">## If your site <span class="keyword">is</span> <span class="keyword">put</span> in <span class="keyword">a</span> subdirectory, <span class="keyword">set</span> url <span class="keyword">as</span> <span class="string">'http://yoursite.com/child'</span> <span class="built_in">and</span> root <span class="keyword">as</span> <span class="string">'/child/'</span></span><br><span class="line">ur<span class="variable">l:</span> http://www.shup.<span class="keyword">cn</span>	#这里修改你的网址或者IP</span><br><span class="line">roo<span class="variable">t:</span> /</span><br></pre></td></tr></table></figure>
<p>部署项配置：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="attribute">deploy</span>:</span><br><span class="line">  <span class="attribute">type</span>: git	#部署方式</span><br><span class="line">  <span class="attribute">repo</span>: hexo<span class="variable">@www</span>.shup.<span class="attribute">cn</span>:/home/hexo/hexo.git #@符号之前是服务器的管理用户，之后是服务器的git仓库路径</span><br><span class="line">  <span class="attribute">branch</span>: master	#分支，我们只用主分支即可</span><br></pre></td></tr></table></figure>
<h2 id="部署验证"><a href="#部署验证" class="headerlink" title="部署验证"></a>部署验证</h2><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">hexo clean	<span class="comment">//清除缓存（实际是删除db.json和public文件夹）</span></span><br><span class="line">hexo g	<span class="comment">//生成静态页面（public文件夹）</span></span><br><span class="line">hexo d	<span class="comment">//部署到服务器</span></span><br></pre></td></tr></table></figure>
<p>OK，完结撒花，浏览器输入你的域名看看吧！</p>
<p>其实就是最初给你预览的helloworld，只不过它搬到服务器了！</p>
<p>以后我们发布博客就用我讲解Hexo那一章的第2-6步就可以了，甚至可以用<strong>hexo g -d</strong>来一键生成发布！这样你就可以专心写md了，发布只是一个命令的事！</p>
]]></content>
      
        
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> VPS </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
