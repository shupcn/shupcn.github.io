<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[让你的代码变得更简洁、干净]]></title>
    <url>%2F2017%2F11%2F29%2Fcleancode.html</url>
    <content type="text"><![CDATA[你是否见过下面这样的代码？ public String getProductNames(List&lt;Product&gt; products) &#123; StringBuilder strBuf = new StringBuilder(); int i = 0; strBuf.append(products.get(0).name); while (i &lt; products.size()) &#123; strBuf.append(", "); strBuf.append(products.get(i++).name); &#125; return strBuf.toString();&#125; 这样的代码存在于一些保留系统(Legacy System)中，通常很旧。当你看到这样的代码时，很可能感觉不太友好。 这段代码的问题在于：不仅太冗长，更重要的是它隐藏了逻辑（还有一些其他问题，后面讨论）。我们编写代码来解决问题，因此，不应该在代码中创造新的问题。请注意，当编写“系统代码”或者以高性能为目标的库时、或者我们需要解决的问题技术太过复杂时，是可以牺牲可读性。但是即便如此，还是应该尽量避免编写隐藏逻辑且晦涩难懂的代码。 罗伯特·马丁 (Bob大叔)在他的书《Clean Code》中提到 “阅读代码和编写代码的时间比例远远超过10比1”。在一些保留系统中，你要花费大量的时间试图理解如何 阅读代码，而不是实际阅读代码。测试和调试这样的系统也是非常棘手的，大多数情况下，你需要用非常规的方式完全来完成。 代码也在讲故事写代码也是写作的一种。代码不应该隐藏解决问题的逻辑或算法。相反，它应该条理清晰的列出各种函数名称，模块等，甚至代码的格式看起来像已被谨慎和专业地处理过的。 看到下面这段代码有什么感觉？ int calc(int arr[])&#123; int i; int val = 0; for ( i = 0;i&lt;arr.length;i=i +1 ) val = val+1; int j = 0; int sum = 0; while (arr.length&gt;j) &#123;sum += arr[j++] ;&#125; int ret = sum - val; return ret;&#125; 这段代码看起来像战后的战场。看上去碰过这段代码的开发者都很烦它，且尽力回避它，让它处于更糟的状态。凌乱的格式和糟糕的定义清楚地表明，不止一个开发人员掉过坑，听起来像破窗理论对吧？想明白这段代码的功能并不容易（不仅仅是因为你看代码时感觉辣眼睛），这段代码其实返回的是数组的总和减去元素的数量。让我们以更简单的方式来做到这一点： int sumMinusCount(int arr[]) &#123; int sum = IntStream.of(arr).sum(); int count = arr.length; return sum - count;&#125; 现在，用Java 8的Stream，让代码更加简洁并增强可读性。 干净的代码！干净的代码不是让代码看起来漂亮，而是使代码更易于维护。当代码太晦涩难懂时，大部分时间浪费在阅读上，导致开发者的生产力降低了，而且使用它的开发人员通常也会让它变得更糟，就像上面讲的那样。原因并不是因为他们无法理清代码，而是由于时间和精力的限制。碰到这样的代码时，很难估计修复bug、植入一个新模块或实现一个新功能需要多长时间，因为原框架和设计隐藏在代码中，不容易发现。因此，为了完成工作，最终会选择草草了事。干净的代码可以表明作者的意图，即便在代码中存在错误，也很容易找到并修复它，也可以长期节省维护时间。 解决（或提高）代码可维护性的方法是花费几个月（或更多）的时间来重构和清理，但是不管企业还是个人通常不太可能接受暂停开发，重构代码。所以，我们能做些什么？ 童子军原则正如Bob大叔所说，“童子军原则”背后的想法其实非常简单：让代码更干净！任何时候你碰到旧的代码，应该先妥善地清理好它。不要只是快捷方式处理，让代码更难理解，而应该认真地对待。这个原则更多地关注开发者应该具有的心态，通过把代码变得更易于维护，让他们的日子过得更舒服。 在大多数情况下处理保留系统是很不容易的，特别是当没有测试或测试套件不再被维护的时候，仍然应该努力使代码更干净。关于如何编写更具表达性的代码，这篇文章更关注一些有用的、一般性的建议。 编写前的思考有个常见的误解：开发的人员开发软件或系统时仅仅是写代码。事实并非如此，相反，我们编写代码来解决问题。代码只是一个媒介，而不是实际的解决方案。随便敲几个键盘是写代码吗？当然不是，因为不可能被电脑编译。同样，没有先考虑如何解决的问题就开始编写代码也不是常规做法。因此，当写代码时，必须三思而后行，以便通过代码提供的解决方案清晰且不模糊。不应该为了写代码而写代码，代码应该解决问题，而不是创建新的问题。 有没有在检查代码时，意识到代码完全错误，唯一的解决办法是从头再写？许多开发人员接到新任务，就立刻开始在IDE中输入内容。他们认为，这样做看起来像在认真工作。大多数情况下，这被证明是错误的方法，因为没有思考就开始写代码会导致错误的方向。当然，不排除一些非常有经验的开发人员可以立刻开始编写，并且仍然朝着正确的方向发展，但是大多数开发者在碰键盘前还是需要仔细计划好。 考虑一下下面这个例子: class Customer &#123; private List&lt;Double&gt; drinks; private BillingStrategy strategy; public Customer(BillingStrategy strategy) &#123; this.drinks = new ArrayList&lt;Double&gt;(); this.strategy = strategy; &#125; public void add(final double price, final int quantity) &#123; drinks.add(strategy.getActPrice(price*quantity)); &#125; // Payment of bill public void printBill() &#123; double sum = 0; for (Double i : drinks) &#123; sum += i; &#125; System.out.println("Total due: " + sum); drinks.clear(); &#125;&#125;interface BillingStrategy &#123; double getActPrice(final double rawPrice);&#125;// Normal billing strategy (unchanged price)class NormalStrategy implements BillingStrategy &#123; @Override public double getActPrice(final double rawPrice) &#123; return rawPrice; &#125;&#125; 上面这段代码来源于维基百科。这个例子中的代码没有什么不好，是吧？其实不然，这段代码使用了Strategy Pattern，表明它需要有一定的灵活性。但在这个例子中，与维基百科不同，只有一个策略实现，且并没有实现更多策略的计划。这里使用Strategy Pattern的意图可能会误导读者，通常实现一个Pattern需要费不少功夫，所以读者自然会想，用这个的原因是什么。YAGNI原则(You aren’t going to need it)，除非你需要它，否则别创建新功能，避免创建你不要的代码。预测未来需要什么是很难的，有时候过往的经验会有帮助，但是在大多数情况下，保持简单还是比较安全的。 使用Pattern帮助我们以一种易于沟通的优雅方式来解决特定的问题。如果本身问题不存在，读者将被误导，反而认为问题确实存在。请注意，并不是反对Pattern，问题是人们总是试图在Pattern解决的问题同时创造新问题，就因为他们知道Pattern这回事。 不要以为代码可以正常编译，就完活了！其实，在代码编写完成的时候，只是完成了一半，要继续工作使代码可以向读者传达我们的意图。 我们的工具集中有很多工具，要在适当的时候使用它们。仅仅因为每个人都在用框架和库就随大流是没有任何意义的。要了解他们到底解决了什么问题，学习以一种不隐匿的方式来使用它们。如何处理框架和库，这里Bob大叔 还有一个很棒的帖子：《Make the Magic go away》。 提高表达性如今，许多编程语言都支持Stream来帮助我们编写表达性代码，例如Java，Kotlin，JavaScript等。Stream已经用if语句取代了冗长的循环，相对于命令式编程，帮助我们用更具声明式编程的方式来考虑数据转换。为了要找到所有小于某个值的元素就反复声明是没有意义的，只需简单地将过滤器应用于Stream。 命令式编程：命令机器如何 去做事情(how)，这样不管你想要的是什么(what)，它都会按照你的命令实现。 声明式编程：告诉机器你想要的是什么(what)，让机器想出如何 去做(how)。 几乎所有支持Stream的语言都有Map, filter 和 reduce。所以，每个人都可以理解你写的东西，就像每个人都能理解一个循环或者一个if语句一样。用这样的表达式来处理数据是非常强大的。首先你就不用测试这个功能。有没有注意到第一个例子中的差一错误 ？这也使我们走向了函数式编程。 第一个例子中的基于Stream 的解决方案如下： public String getProductNames(List&lt;Product&gt; products) &#123; return products.stream() .map(p -&gt; p.name) .collect(Collectors.joining(", "));&#125; 简单又干净，很容易理解它做什么。现在，考虑下面的例子： void getPositiveNumbers(List&lt;Integer&gt; l1, List&lt;Integer&gt; l2) &#123; for (Integer el1: l1) if (el1 &gt; 0) l2.add(el1);&#125; 当你调用这个method时，第二个参数会改变吗？这个method是按照编写的去实现吗？Method的名称是否合适？你真的能“get”吗？ 这样呢？ List&lt;Integer&gt; getPositiveNumbers(List&lt;Integer&gt; numbers) &#123; return numbers.stream() .filter(num -&gt; num &gt; 0) .collect(toList());&#125; 在这个例子中，返回值是一个新的列表，没有参数受到影响。我们只是读取参数并产生一个新的结果，但要理解这个method在做什么以及如何使用它，第二段显然更容易。这种method也可以很容易地与其他method组合，一般而言，组合是Stream和函数式编程的最重要的好处之一。组合能使我们从更高层次的数据转换、过滤等方面进行思考，并编写出更具声明式编程和表达性的代码，让代码表达我们想要实现的(what)而不是如何完成的(how)，这大大改善了代码的可读性。 把一个问题分解成多个子问题，解决每一个子问题，然后组合这些解决方案，为最初的问题提供解决方案，就容易多了。但另一方面，当主要目标是性能时，命令式编程可能又是必不可少的。 请注意，Jave 8中的toList()收集器返回一个可变列表，而在函数式编程中，我们通常使用不可变数据结构。不过，生成新数据并将参数视为只读可以提高method可读性和表现。虽然有些method可能有副作用，但对于一种method来说，要么有副作用（表现为command），要么有返回值（表现为query），不会同时存在。 写更具表达性的代码不是一件容易的事情。爱因斯坦说过：“If you can’t explain it simply, you don’t understand it well enough”。所以，当看到抽象层次代码混合时，例如与数据访问对象(DAO)交互的UI类，或者直接与数据库talk，或者低层次的细节在不应该暴露的时候暴露，可以说不仅违反了单一职责原则，而且还有些混乱。通过使用注释来解决并非最佳解决方案。有人写的越简单、越具表达性，说明他对这个问题的理解就越好。 拥抱不可变对象当对象的状态发生变化，而又没有注意到它的时候，是非常让人困惑的。对构造一半的对象使用return时也是很危险的，特别是处理多线程的程序时。而不可变对象对多线程是安全的，也是完美的缓存对象，因为它们的状态不会改变。 但是为什么选择可变对象呢？最有可能的原因是为了性能表现，因为占用的内存会少一些，因为改变是在原地(in-place)进行的。而且，让一个对象的状态在其整个生命周期中发生变化是很自然的，这是我们在面向对象编程(OOP)中学到的。这些年来，我们一直在写程序，其中大部分的对象都是可变的。 今时不同往日，机器内存的数量、性能比之前翻了N个数量级，真正面临的问题是可扩展性。处理器的速度虽然不再像过去十几年那样猛增了，但现在有了N多核的CPU。所以，需要利用好现在的情况来规划好程序。由于程序需要能够在多个内核上运行，所以要以一种安全的方式来编写。使用可变对象，必须处理好locking以确保其状态的一致性。并发（详解）不是很好处理的。而不可变对象（状态在对象被创建之后就不再变化）在多线程和处理器之间共享是固有安全的，且不需要同步的特性为创建具有低延迟和高吞吐量的系统提供了机会。因此，不可变对象是实现可扩展，更安全的选择。 除了可扩展的好处，不可变对象使我们的代码更简洁、干净了。在上一节的示例中，作为参数传递的集合在调用method后发生了改变。如果是不可变集合，则是不允许的。因此，不可变对象可以促进更好的解决方案。另外，由于状态不变，读者也不需要费心思记，只需要将一个对象名称与一个值关联起来。 程序必须是为人们阅读而写的，只是偶尔地让机器执行。 ——Harold Abelson，《计算机程序的构造和解释》]]></content>
      <tags>
        <tag>干净代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用免费的Google Cloud来部署科学上网神器SS]]></title>
    <url>%2F2017%2F11%2F23%2Fss.html</url>
    <content type="text"><![CDATA[之前一直想搞个搬瓦工或者vultr的VPS来部署SS，实现科(V)学(P)上(N)网，但始终抢不到优惠的实例。偶然间发现Google Cloud在免费，而且貌似免费期从之前的2个月提高到1年，这样看来不用花一分钱，即可实现爱(翻)国(墙)上网，还可以再享受配置、性能更高、更稳定Google服务器，岂不美哉！ Google Cloud免费简介Google Cloud顾名思义即Google提供的云计算服务，和国内的阿里云、腾讯云、百度云类似。提供的服务无非也就那几大类：基础云计算服务、大数据类、物联网、CDN等等。免费以300刀赠金形式，可以体验所有产品当然也包括Compute Engine(即VPS)，需要注意Google的云主机计费方式与国内不同之处在于：国内一般是全包，而Google是云主机、公网IP和流量分开计费，需确保你在一年内的消费不超过300刀，后面会详细讲。 申请与开通VPS主机在一切操作前，你需要先有一个临时的科(V)学(P)上(N)网环境，因为注册和配置Google云服务的工作需要在Google网站上完成。可以在手机里操作，目前有很多相关APP有免费使用时长，半个小时足以。 另外，你需要准备好： 一张Visa或者万事达的信用卡(会扣1美元验证卡真实性，几分钟后就会退还。) 一个美国电话号码(可以用iPlum。非必须，仅仅为提高通过率，目前号码不需要验证，所以非真实号码应该可以。) 一个美国地址(自己去搜索，地址需要真实) 准备就绪： 登陆Google Cloud主页：cloud.google.com，点击TRY IT FREE，登陆你的Google账号。 地区选择美国，然后同意服务条款后，账户类型选择个人，填上地址、信用卡信息，即可开通账户。 开通后创建VM实例，按照下面2张图配置即可，笔者选的是1核1G内存10G硬盘CENTOS6系统，asia-east1-c节点(台湾)。也可根据自己需求选择配置。另外在网络那里选择添加外部静态IP(即公网IP地址)。最后点创建即可开通云主机。 这里说一下配置的选择及价格：主机的价格表不在此列举，自己选择适合的。公网IP基本上是免费，那就来梳理一下流量的计费方式： 流量类型 价格 入口 免费 出口*到同一区域 免费 出口在同一区域内不同的谷歌云平台服务 免费 出口到谷歌产品（如YouTube，Google地图，驱动器） 不收费** 在同一地区区域之间的出口（每GB） $ 0.01 在美国国内地区之间的出口（每GB） $ 0.01 洲际出口 参考下面表格 每月使用 网络(出)全球(不包括中国和澳大利亚，但包括香港)(每GB) 网络(出)中国(不包括香港)(每GB) 网络(出)澳大利亚(每GB) 网络(入) 0-1 TB $ 0.12 $ 0.23 $ 0.19 免费 1-10 TB $ 0.11 $ 0.22 $ 0.18 免费 10+ TB $为0.08 $ 0.20 $ 0.15 免费 可以看出如果每月流量不超过1TB，就是$0.23月/GB。以最低配主机(如果仅仅用于科学上网，最低配没问题)为例，$5/月，一年是$60，还剩下$240用于流量的开销，240 / 0.23 = 1043GB， 1043 / 12个月 = 86GB 也就是每个月用 86GB流量，足够了。当然也可以选择更高配置的主机，这样流量少一点，自己权衡。 配置防火墙开通主机后，因为后面要配置SS，默认的防火墙限制太多，需要修改防火墙规则。在控制台/VPC网络/防火墙规则里，名称随便写，其他按下图配置即可。IP地址范围： 0.0.0.0/0 配置SSH 用 PuTTYgen生成密钥使用SSH工具Xshell或者Putty，这里以Putty为例，使用方法参考之前文章，Putty安装好后程序包里有一个PuttyGen工具，打开后，直接点击Generate来生成一对密钥用于登陆SSH。注意： 生成好后在key comment处，原本生成的应该是rsa-key-20171123，需要修改成rsa-key-20170905XXXX，XXXX是你申请Google Cloud 时，“XXXX@gmail.com” 前的字符，说白了就是你邮箱的用户名。完成后将 public key 保存，保存为.pub格式文件，然后保存 private key，保存为.ppk文件格式！ Google Cloud控制台 导入公钥在控制台/compute engine/元数据中，右边点击SSH密钥，点击修改，添加刚刚保存的公钥.pub文件里的内容进去保存即可。 Putty里导入私钥 连接实例打开Putty ，在Connection/SSH/Auth, 导入刚刚保存的私钥.ppk文件。如下图。接下来回到session，在Host Name (or IP address)中填入步骤1修改过的 Key comment ＋@实例 ip(比如rsa-key-20170905name@8.8.8.8)，即可登录SSH。 连接成功后，输入sudo -i即可获得root权限。 SS的安装与配置先来说说SS特点 ： 省电（在电量查看里几乎看不到它的身影） 支持开机自启动，且断网无影响，无需手动重连 可使用自己的服务器（安全和速度的保证） 支持区分国内外流量（PAC模式） 可对应用设置单独代理 安装和配置主要是参考秋水逸冰文章： 在VPS上安装SS前，需要先安装最新内核并开启 BBR，可以使用秋水逸冰的一键安装脚本，具体看这里。BBR 即拥塞控制算法，目的是要尽量跑满带宽, 并且尽量不要有排队的情况, 效果并不比速锐差。据很多人反馈，速度比锐速还厉害！！ SS的安装和配置具体也可见秋水逸冰一键安装脚本。一般选择Python版。 最后在Win、Mac、IOS、android中下载对应的SS客户端，填入以上配置好的IP、端口、密码，选择相应的加密方式(Win下，右键任务栏纸飞机小图标，启用系统代理)，即可去探索外面的世界了。]]></content>
      <tags>
        <tag>SS</tag>
        <tag>科学上网</tag>
        <tag>VPS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Valine插件为Hexo博客添加评论功能]]></title>
    <url>%2F2017%2F11%2F21%2Fvaline.html</url>
    <content type="text"><![CDATA[Hexo由于其静态特性，具有一定的局限性，因此需要借助于第三方服务来扩展站点的功能。作为一个博客系统，Hexo几乎完美，唯独(默认模式下)差了一个最重要的互动功能——访客评论。NexT主题内置了多款第三方评论系统：多说、畅言、有言、disqus、gitment等等，试用过后都觉得差强人意。不经意间发现了Valine，部署简单，界面风格简洁，调用迅速(无后端)，还支持Markdown，这简直就是Hexo的绝配。 至于放弃其他几个系统，主要原因有以下： 多说 - 这个不必多说，已经关闭； 畅言 - 搜狐旗下，应该不错，不过域名需要备案才可以使用，是一个不小的门槛； 有言 - jiaThis旗下，使用过程中遇到多次无法在页面中正常加载的情况，不稳定； disqus和gitment - 一句话，远在大洋彼岸不适合国内使用。 Valine简介 Valine(官网)是一款基于Leancloud的快速、简洁且高效的无后端评论系统。 特性 快速 安全 无后端实现 MarkDown 全语法支持 轻量易用(~15kb gzipped) Valine配置及使用获取appid和appkey请先登录或注册 LeanCloud, 进入控制台后点击左下角创建应用，选择免费的开发版即可。注意右上角有几个节点，可以就近选择。应用创建好以后，进入刚刚创建的应用，选择左下角的设置&gt;应用Key，然后就能看到你的appid和appkey了：为了数据安全，请注意设置自己的安全域名： Hexo-NexT中的开启和设置Hexo-NexT中已经默认安装了Valine插件，如果没有可以使用以下命令安装： npm install valine --save 完成后，在NexT主题配置文件中加入/修改代码以开启： # Valine.# You can get your appid and appkey from https://leancloud.cn# more info please open https://valine.js.orgvaline: enable: true # 是否开启 appid: # 填上之前获取的AppID appkey: # 填上之前获取的AppKey notify: false # 新留言是否需要通知 https://github.com/xCss/Valine/wiki verify: false # 是否需要验证，验证比较反人类建议false关闭 placeholder: 请在此输入您的留言 # 默认留言框内的文字 avatar: mm # 默认头像 guest_info: nick,mail # 默认留言框的头部需要访问者输入的信息 pageSize: 10 # pagination size #默认单页的留言条数 OK，至此已经已经完成配置并成功开启，Hexo g -d赶紧去看效果吧。 后期如果需要管理留言，至leancloud/控制台/储存/comment即可进行添加、删除等操作。]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>Valine</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用又拍云CDN加速Hexo博客]]></title>
    <url>%2F2017%2F11%2F21%2Fcdn.html</url>
    <content type="text"><![CDATA[辛辛苦苦搭建好博客，虽然Hexo本身是全静态网页，页面加载速度相对于动态博客程序已经是非常可观，但NexT主题调用了不少js文件，如果再加上其他的图片、音视频插件等等还是会在一定程度上造成延迟。本着折腾不止和完美主义的精神，用CDN来加速Hexo！ CDN加速的原理这里简明扼要地解释一下CDN加速的原理：你上传到CDN加速网站(如又拍或者七牛)空间里的文件(或者网站)以镜像的形式存放到多台服务器，这些服务器分布在祖国甚至全世界各地，访问者就近读取较快的镜像，以实现快速加载的效果。举个栗子：你的文件(或网站)在上海，没有CDN，一个北京的访问者需要直接连接你在上海的服务器，有了CDN，这个北京的访问者只需要访问你的文件(网站)在北京的镜像即可。尤其是国内外的互访，CDN可使访问速度大大提升。 哪些因素会影响加载速度？js文件js文件就是JavaScript脚本文件，用来实现各种酷炫的动态效果。一般是加载在html页面的&lt;head&gt;部分，所以页面加载速度首先要考虑这一块。Hexo的js文件大致包含以下3类： 公共js公共js是通用型，比如实现图片放大效果的Fancybox，或者实现图片慢加载的LazyLoad等等。这些js已经开发好，直接在html里引用(存放在镜像网站上，如BootCDN)js文件链接即可实现效果。 定制页面效果js即NexT主题中定制的某些特效，例如实现页面响应式效果的Bootstrap，或者增强移动端滚动及动画效果的Motion等等。这些js理论上也是公共js，只不过NexT主题作者修改了代码，以适用于NexT主题。这些js文件存放在本地Hexo目录hexo\themes\next\source\js\src下。 第三方插件js这个不用多说了吧，Hexo默认安装了不少实用的第三方插件，比如，可直接在网页中显示数学公式的MathJax，优化SEO的Baidu-push等等。这些插件可在主题配置文件_config.yml中进行配置。相关js文件有些存放在hexo\themes\next\layout\_third-party中，有些则通过外部引用形式加载。图片(音、视频)如果博客文章很多，绝大部分的带宽都会消耗在这部分静态数据上。这个不多说了。Google字体引用很多文章中提到，由于被墙的缘故，引用Google字体会严重拖累网站，于是乎屏蔽Google字体的插件层出不穷。不过笔者测试发现，无论是Google字体中文官网，还是Google字体的引用服务器fonts.googleapis.com都没有被墙，而其速度在全球范围内都相当理想(如下图)，所以完全没有必要修改Google字体的引用源，比如改成360CDN什么的。 综上，下面就开始着手对Hexo博客的js文件和图片(音、视频)文件进行CDN加速。 CDN加速公共js加速在版本 5.0.1 之后的NexT主题，有一个方便的功能可以通过修改主题配置文件_config.yml中常用外部js的引用地址，来实现自定义CDN加速。下面是此部分的配置(在_config.yml搜索CDN即可找到)，笔者已经修改成BootCDN的引用地址。关于国内靠谱的JavaScript CDN库，还是推荐BootCDN，可参考知乎的讨论。 # Script Vendors.# Set a CDN address for the vendor you want to customize.# For example# jquery: https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js# Be aware that you should use the same version as internal ones to avoid potential problems.# Please use the https protocol of CDN files when you enable https on your site.vendors: # Internal path prefix. Please do not edit it. _internal: lib # Internal version: 2.1.3 jquery: https://cdn.bootcss.com/jquery/2.1.3/jquery.min.js # Internal version: 2.1.5 # See: http://fancyapps.com/fancybox/ fancybox: https://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js fancybox_css: https://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css # Internal version: 1.0.6 # See: https://github.com/ftlabs/fastclick fastclick: https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js # Internal version: 1.9.7 # See: https://github.com/tuupola/jquery_lazyload lazyload: https://cdn.bootcss.com/jquery_lazyload/1.9.7/jquery.lazyload.min.js # Internal version: 1.2.1 # See: http://VelocityJS.org velocity: https://cdn.bootcss.com/velocity/1.2.1/velocity.min.js # Internal version: 1.2.1 # See: http://VelocityJS.org velocity_ui: https://cdn.bootcss.com/velocity/1.2.1/velocity.ui.min.js # Internal version: 0.7.9 # See: https://faisalman.github.io/ua-parser-js/ ua_parser: https://cdn.bootcss.com/UAParser.js/0.7.9/ua-parser.min.js # Internal version: 4.6.2 # See: http://fontawesome.io/ fontawesome: https://cdn.bootcss.com/font-awesome/4.6.2/css/font-awesome.min.css # Internal version: 1 # https://www.algolia.com algolia_instant_js: algolia_instant_css: # Internal version: 1.0.2 # See: https://github.com/HubSpot/pace # Or use direct links below: # pace: //cdn.bootcss.com/pace/1.0.2/pace.min.js # pace_css: //cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-flash.min.css pace: https://cdn.bootcss.com/pace/1.0.2/pace.js pace_css: https://cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-flash.min.css 使用Chrome浏览器开发者工具-&gt;Network，按住Shift+刷新(全新加载)即可看到效果。下图显示加速的效果非常好！修改前首页加载需要10秒以上，其中尤其index.js(即JQuery.js)严重拖累了加载速度。修改之后，基本上就是——秒开！ 页面效果js加速这些js文件存放在本地，原则上把它们上传到CDN加速空间中，再修改引用源即可。但基于以下原因考虑，这里不做修改。 这些js文件对加载速度影响不大； 如果主题更新又会恢复到原始状态； 修改引用源改动源文件较多、比较麻烦。 插件js加速同样道理，这些js文件若是存放在Hexo本地的，需要将他们上传到CDN加速空间里；如果是外部引用，需要先将引用地址的原js文件下载下来，存放到CDN加速空间里。最后统一修改原引用地址到CDN加速空间地址。 下面以又拍云的CDN为例介绍，注册开通很简单，这里略过。需要注意不管七牛还是又拍，注册时都需要上传手持身份证的照片进行身份核验。身份认证后即可开始操作，具体操作方法请参考官方文档。简单说两句：创建的服务选择网页图片类型，然后添加操作员、密码即可，后面如有需要还可以绑定域名(需备案)，https等等。 一切就绪后，下面以加速valine.js插件为例说明。Valine是一款评论插件，安装及配置请参考《使用Valine插件为Hexo博客添加评论功能》。 开启并配置好Valine后，打开hexo\themes\next\layout\_third-party\comments\valine.js可以看到如下代码： &lt;script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"&gt;&lt;/script&gt;&lt;script src='//unpkg.com/valine/dist/Valine.min.js'&gt;&lt;/script&gt; 可以看出Valine的运行是依赖以上2个外部js文件，这里以加速第二个js文件为例，修改第二个js文件的源为： &lt;script src="//XXX.test.upcdn.net/Valine.min.js"&gt;&lt;/script&gt; # XXX改成你的又拍云服务名 然后，把原js文件Valine.min.js、即https://unpkg.com/valine/dist/Valine.min.js下载下来，通过FTP工具(推荐FileZilla)上传到你的又拍云空间根目录里。 这样，Valine.min.js这个文件就在用又拍云进行CDN加速了。Hexo g -d查看效果吧。其他插件js的加速理论上适用上述方法，关键是第一步要找到js文件正真的源引用地址。 图片(音、视频)加速其实如果以上的操作没有问题，图片(音、视频)的CDN加速也是同样的方法。 比如，你的文章里有本来有一张图片，图片地址为http://xxx.com/123.jpg。把这个图片上传到你的又拍云空间里，即可获得地址：http://xxx.test.upcdn.net/123.jpg，将此地址插入到文章中即可实现图片的CDN加速。而且后期还可以利用又拍云的云处理功能对图片增加缩略图、水印、防盗链，对音视频转解码，压缩等等。 如果你理解以上的原理，可以将其他任何类型(一般加速图片，音频，视频，js，css等)的静态文件的转移到CDN上，从而将你的网站优化的更好。]]></content>
      <tags>
        <tag>CDN</tag>
        <tag>Hexo</tag>
        <tag>又拍云</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在阿里云VPS上部署Hexo]]></title>
    <url>%2F2017%2F11%2F16%2Fhexo.html</url>
    <content type="text"><![CDATA[自双11购入了阿里云的VPS后，一直想着捯饬些什么，首当其冲的就是搭一个博客站点。之前使用过WordPress、Joomla、Drupal、国人的Typecho、Emlog、Zblog等。前几个国外的博客虽然功能、插件、模版丰富，但感觉略显臃肿，过多冗余之处，不适合做个人站点使用，尤其不适合笔者的1G1M的小水管主机。而国人的Typecho、Emlog感觉不错，安装使用简单、占用内存少、界面清新，没有多余的功能，支持Markdown，还原写作本质。但在使用中，出现不少小问题，细节不完善，影响实际体验，遂弃之。直到遇见了Hexo…… Hexo的介绍不再赘述，可以登录其中文官网了解。其实在接触Hexo之前，笔者就对纯静态的博客框架有所了解，比如jekyll、octopress等。与Hexo一样，他们的共同的优点就是部署页面纯静态html，加载速度快、浏览体验好、占用内存小，支持Markdown，当然最重要的一点是有逼格。最终放弃Jekyll等等选择Hexo的原因是：相对于Jekyll基于Ruby实现，Hexo基于Node.js，在Windows上安装Node.js环境更简单，另外，Hexo的主题更符合我的品位。 这类静态博客系统最大的一个缺陷就在于要求用户具有一定的技术水平，Hexo是我见过最难建立的博客系统。网上有很多文章是把Hexo部署到Github或者Coding等，优点是搭建快捷、免费，缺点显而易见，Github远在大洋彼岸，加载速度可想而知，而Coding则是有广告。既然已经有了云主机，当然不能浪费。笔者阅读了网上N多文章及教程，踩过坑，走过弯路，在经历N次的失败后，终于搭建成功。下面就把最简明扼要的过程列出来，谨以此自勉或造福后人。 准备条件VPS及域名笔者购买的是阿里云的轻量云服务器，1核1G1M20GSSD，CentOS 7.4系统，搭配宝塔面板(方便可视化操作)，本文操作过程理论上适用于其他Linux系统。域名需添加A解析记录指向主机IP，域名购买、解析(国内VPS需备案)的过程请自行搜索。 SSH工具SSH工具是我们用来以命令行的方式远程操作服务器端。Putty小巧、免费，Xshell功能更强大，但是收费。笔者使用的是Putty，点此下载(最新版)，注意本地操作系统，自行下载相应版本安装。如何使用SSH工具连接VPS，请看阿里云的官方教程。 本地端配置本地配置很简单，依次安装好Node.js和Git,再安装Hexo即可，Hexo需要前两者的支持。本人是用的win10系统，本地端不需要什么配置，只要安装相应版本即可，Mac或Linux系统应该更容易。 安装Node.js这里给出Node.js官方下载链接：https://nodejs.org/zh-cn/download/安装没什么好说的，一路默认下一步即可。 安装Git同样给出Git官方下载链接：https://git-scm.com/downloads对应自己的本地系统下载即可，这个套件不仅仅在windows上安装了Git版本控制系统，最重要的是这个套件提供了Git Bash，一个可以在windows上运行的Linux风格shell，除非你够硬核，能忍受win的cmd，否则通过Git Bash使用hexo无疑是最佳选择。下图的选项建议勾选，视觉效果有明显提升。其余选项保持默认即可。 安装并熟悉HexoHexo最好的教程当然是官方文档！先不用花时间全看完官方文档，这里稍微说下要点，部署好之后可以仔细研究官方文档。 首先是安装，在Git Bash下输入这条命令就安装Hexo了，简单吧。不过这仅仅是把Hexo的程序写进了系统，网站还没有部署好。 npm install -g hexo-cli 注意：npm在国内被墙了，国内用户需要挂代理，否则输入命令后半天没反应。这里推荐一个最好的办法。每次要用npm命令时，先输入以下命令行。 npm config set registry https://registry.npm.taobao.org 接下来熟悉怎么使用Hexo 首先建立一个站点 hexo init &lt;folder&gt; //以folder为目录名建立站点文件夹cd &lt;folder&gt; //转移到站点目录npm install //安装依赖 一个网站对应着一个站点文件夹，这里就是你的整个Hexo博客网站。之后的操作我们都在该站点目录下进行。 以上，也可以先新建一个文件夹，直接右键Git Bash Here。然后hexo init即可。 新建一篇文章 hexo new &lt;title&gt; 新建立的文章是markdown（以下简称md）文件，熟悉mac的一定知道吧，不熟悉的几分钟就能上手。我们编辑博客就是用编辑md文件实现的。在source/_post目录下，我们看到里面已经有个hello-world.md了。 编辑文章就是编辑你新建的md文件啦。这就需要markdown编辑器喽，当然mac就省事了，对于win系统，Typora和MarkdownPad编辑器，看个人喜好选择。 启动本地服务器 hexo s 这条命令会在本地启动服务器，访问地址为localhost:4000，主要是我们正式发布前预览测试用的，启动后你编辑文章和主题等都可以直接更新到该网址，非常方便！但是注意，编辑站点配置文件_config.yml是需要重启该服务器才生效的。现在我们就看下自带hello-world.md的预览效果吧。还是蛮酷炫的吧！ 这里有个坑吐槽一下，若Win安装了福某PDF阅读器会占用4000端口，需要用hexo s -p 5000命令把端口换成5000来执行启动。 生成静态文件 hexo g 这条命令是由各种md文件和资源生成可部署的静态html页面等，生成的资源都放在新生成的public目录下。 部署到服务器 hexo d 部署方式有多种，对这篇文章来说，就是利用Git部署到你的VPS服务器了，当然在这输入是没卵用的~还没配置服务器端。 掌握以上命令基本就OK了，还有一条hexo clean用来清理缓存，其他的一般用不到，有兴趣的再看官方文档。接下来我们看VPS服务器端配置。 VPS服务器端配置这一部分的配置就用之前说的Xshell或putty来搞定！ 创建用户创建用户用于服务器端站点管理，如下： adduser hexo //创建用户passwd hexo //设置密码su //检查是否有安装sudo 有的linux系统初始没安装sudo，为了方便，我们需要安装sudo，已有安装的话，跳过这步。 yum install sudo 再次，为了方便，赋予hexo用户root权限，使用vi命令在/etc/sudoers中添加一行。不会vim编辑临时搜一下，简单，当然也可以通过宝塔面板进行可视化操作。 vi /etc/sudoers 找到这一行添加： root ALL=(ALL) ALLhexo ALL=(ALL) ALL #这个是添加的 配置本地端无密码ssh登录服务端这里为什么要用到Git呢？因为这里的Hexo发布博客是用Git来部署的，而Git又是基于ssh连接的，所以实现一键发布博客就得配置这玩意了。其实很简单，有的教程复杂化了，注意这里最后一步是在本地端操作。 服务器端生成ssh密钥 su hexocd /home/hexomkdir .sshcd .sshssh-keygen -t rsa 在生成密钥时，会要求你输入一个加密密码，可以不填写(一路回车)，实现无密码登陆。完成后会在/home/hexo/.ssh/文件夹下生成2个key，一个公钥id_rsa.pub，一个私钥id_rsa，编辑此文件夹中的authorized_keys文件(如没有则新建一个)，把公钥里面的内容全部复制粘贴进去(包含公钥开头的ssh-rsa)。然后把公钥和私钥2个文件下载到本地，后面会用到。 服务器端确保配置及权限正确(这一步仅为确保，可暂时忽略，若后面ssh连接不成功可返回此步骤检查) 查看/etc/ssh/sshd_config文件配置是否如下： HostKey /etc/ssh/ssh_host_rsa_keyRSAAuthentication yes PubkeyAuthentication yesAuthorizedKeysFile .ssh/authorized_keys 确保用户hexo及.ssh文件夹及相关密钥文件权限正确 chown -R hexo:hexo /home/hexochmod 700 /home/hexochmod 700 /home/hexo/.sshchmod 644 /home/hexo/.ssh/authorized_keys //公钥文件的所有权限chmod 600 /home/hexo/.ssh/id_rsa //私钥文件的所有权限 查看是否有安装ssh并安装，没有的话使用yum安装 rpm -qa |grep ssh //检查是否有sshyum install ssh //如果没有ssh运行，则执行此命令安装ssh 安装完后启动服务 service sshd startservice sshd status //检查是否已启动，看到running即可 本地端ssh配置 打开Git Bash，输入pwd查看本地用户的文件夹地址，如下图，一般默认在C:\User\你的账户名。然后打开用户文件夹里的.ssh文件夹，把刚刚从服务器上下载到本地的两个密钥文件拷贝进去。 本地端ssh验证 ssh hexo@你的域名或者IP //@前是你创建的站点管理用户 OK，无密码ssh登陆完成，配置过程注意是在本地端还是服务器端操作。如果连接不成功，返回上述第2步检查。 安装配置nginx简单来说，nginx是代理服务器，有它我们就能按照域名或IP访问网页了。 添加nginx源，安装nginx在/etc/yum.repos.d目录下创建一个yum源文件nginx.repo,用vi编辑或用宝塔写入如下内容。 [nginx]name=nginx repobaseurl=http://nginx.org/packages/centos/$releasever/$basearch/gpgcheck=0enabled=1 安装nginx(宝塔里面也有一键安装nginx，不过这种方式更简单) yum install nginx -ynginx -v //查看版本号验证 删除原配置文件 rm /etc/nginx/conf.d/* 重新配置，添加以下内容到/etc/nginx/conf.d/hexo.conf server &#123; root /home/hexo/www; #网站根目录,用来存储网站文件，后面会创建 index index.html index.htm; server_name www.shup.cn; #你的域名 location / &#123; try_files $uri $uri/ /index.html; &#125;&#125; 看到没，这一步将你的域名和服务器下的网站根目录挂钩，主页是根目录下index.html很关键！！ 修改nginx配置文件将/etc/nginx/nginx.conf中第一行的user值修改为hexo 切换到hexo用户，用户主目录下新建www文件夹作为网站根目录 su hexocd ~mkdir www 验证配置是否正确，如下图。 启动nginx服务并测试 sudo service nginx startecho "hello nginx" &gt; /home/hexo/www/index.html //站点根目录下新建index.html 在浏览器中输入你的域名或VPS的IP地址，出现hello nginx字样表示nginx代理服务器搭建成功！ 安装配置Git即将完成任务~ 安装Git sudo yum install git 初始化Git仓库用户主目录下新建hexo.git文件夹用作Git仓库并初始化 cd ~mkdir hexo.gitcd hexo.gitgit init --bare //初始化git仓库，bare表示空仓库 配置Git仓库的hooks hooks，钩子，就是将不同目录的数据实现同步。具体如下，在Git仓库hooks目录下创建文件post-receive并修改权限 cd hookstouch post-receivechmod 755 post-receive 将以下内容添加到post-receive中 #!/bin/bashGIT_REPO=/home/hexo/hexo.gitTMP_GIT_CLONE=/tmp/HexoBlogPUBLIC_WWW=/home/hexo/wwwrm -rf $&#123;TMP_GIT_CLONE&#125;git clone $GIT_REPO $TMP_GIT_CLONErm -rf $&#123;PUBLIC_WWW&#125;/*cp -rf $&#123;TMP_GIT_CLONE&#125;/* $&#123;PUBLIC_WWW&#125; 至此，服务器端的配置全部完成。 本地端部署验证接下来我们就试试把博客发布到VPS服务器吧！下面都是本地端的操作。 安装hexo git部署模块国内用户别忘记挂代理。 npm install hexo-deployer-git --save 修改站点配置文件_config.yml# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://www.shup.cn #这里修改你的网址或者IProot: / 部署项配置： deploy: type: git #部署方式 repo: hexo@www.shup.cn:/home/hexo/hexo.git #@符号之前是服务器的管理用户，之后是服务器的git仓库路径 branch: master #分支，我们只用主分支即可 部署验证hexo clean //清除缓存（实际是删除db.json和public文件夹）hexo g //生成静态页面（public文件夹）hexo d //部署到服务器 OK，完结撒花，浏览器输入你的域名看看吧！ 其实就是最初给你预览的helloworld，只不过它搬到服务器了！ 以后我们发布博客就用我讲解Hexo那一章的第2-6步就可以了，甚至可以用hexo g -d来一键生成发布！这样你就可以专心写md了，发布只是一个命令的事！]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>VPS</tag>
      </tags>
  </entry>
</search>
