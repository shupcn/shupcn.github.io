<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[非技术人员的机器学习指南]]></title>
    <url>%2F2017%2F12%2F04%2Fmachinelearning.html</url>
    <content type="text"><![CDATA[人工智能(AI)和机器学习(ML)是目前最热门的话题之一，这两个词几乎随处可见，经常能听到有理想、有抱负的开发者说他们想学习人工智能，又或是企业的管理者说他们想在产品或服务中实现人工智能。但是很多时候，人们并不了解什么才是人工智能、机器学习。 世界末日？首先，我们听说机器学习正在取代蓝领的工作。 人工智能时代，蓝领的未来在哪里？ 然后，我们发现白领的工作也不安全。 Watson治疗癌症准确率超90%，医生该高兴还是难过？ 抛开工作不看，发现机器人之间居然可以聊天。 FB意外发现：聊天机器人开始自创语言了！ 机器学习在很多不同的背景下被讨论，所以很难把握究竟是什么。通过搜索你可能获得一堆抽象的理论解释、或者是拼词游戏、又或是一堆数学和代码。 开始学习所以，机器学习，就是……人工智能？ 我们都或多或少了解人工智能的定义。关于人工智能，每个人有不同的定义，但有一点是共通的： 人工智能是以人类智能相似的方式做出反应的机器智能。 基本上，如果一台计算机做了一些看起来很聪明的事情，就可以将其标记为人工智能。 用一个可能遇到的例子解释：电脑游戏中通常有智能的敌人角色，他们通过不停跟在玩家周围的行事方式，使游戏更具挑战性。游戏的开发者通过一套规则来实现这一点：跟随玩家；如果玩家正在射击，找掩护；如果玩家停止射击，尝试攻击玩家； 这些规则越多，游戏就越聪明。 电脑游戏的开发通常是有限的。玩家只能执行一些特定的、由开发人员设计的操作。所以，开发者可以想出一些看起来非常聪明的AI人物规则。(下面这张图里的人物很聪明吧？) 并非所有的问题都可以通过规则来解决假设我们想要一台电脑来检测这是不是狗的照片：如何为此任务定义规则？ 有四条腿？ 白色的？ 有皮毛？得到下图： 计算机视觉问题，比如识别一个物体，是很复杂的。但是人类的大脑几乎直观地解决了。所以，真的很难明确地定义规则。 进入机器学习我们不用建立一个识别狗的系统，而是建立一个可以学习识别狗的系统。喂给它成千上万的图像资源，包含狗的，不包含狗的。让他自己学习定义狗的规则。 机器学习就是让机器可以像人类一样学习。 关键词“学习”是将机器学习与其他类型的人工智能区分开来的。 “你说机器可以自己学习添加规则。那么，这些规则确实存在咯。我们只是不够努力去发现它们。“ 完全正确！如果努力+努力，可能会开发出一个基于检测狗规则的杰作。这个系统可能涵盖成千上万条规则，包含狗特征的方方面面。但如果现在想让这个系统再检测包含食物的图片呢？那我们只好扔掉之前所有的努力，从头开始，因为狗的那些规则都不适用(可能只有“热狗”适用吧)。简单的办法还是通过扔给它食物的图片来训练学习识别食物。这才是机器学习的正确打开方式。我们有一个灵活的机器，可以学习和适应，而不是给它一套固定的规则。 保持真实听起来像是建了一个鲜活的、可以学习的有机体，让它与小狗玩，以识别狗。然后，我们教它爱的意义，并说服它不要在崛起之后杀了所有人类。 现实情况要复杂得多。我们希望机器学习做决定(通常根据预测)。那么从这个问题开始：人类如何做出预测？ 以下是如何进行预测的一个例子(中学生水平)，假设你进行弹簧实验，收集数据，并将其绘制在图表上。x轴是弹簧负重变量，y轴是测量结果。然后，在图上绘制趋势线。这是对数据进行最佳建模的线。现在你有这条线，你可以做出预测。你可以选择一个未测量过的负重量，读出y轴的预测值。使用数据，建立一个模型，并用它做出预测。如果你把这些步骤写成了一个可以执行的程序，这就是机器学习吗？不完全是，定义线性模型并用它来做出预测：这是一种机器学习技术，称为线性回归。 我们可以将模型编程到系统中，然后系统可以对这个弹簧做出预测。但如果要预测其他弹簧，就得编写新的代码。所以，如果我们教程序自己进行线性回归模型学习，那才是机器学习。 Hocus Pocus(诡计)从上面这个例子中可以学习一件事情，那就是： 机器学习不是变魔术。 我们并没有建立一个能够学习一切的自我意识机体。弹簧的例子永远不会学会识别狗(也许能识别弹簧狗)。我们建立一个可以学习一种特定类型模型的系统，所需要的只是确定何种模型。几乎所有的机器学习系统都具基于下面的模式：系统给出一个基于模型的输出，然后评估这个输出以确定它有多糟糕，然后再更新模型，使未来的输出更好一些。机器学习就是针对不同问题建立一个可执行这个循环的系统。不同的问题，输出可能大相径庭。可能是聊天机器人的文本回应，或者是一个自动驾驶汽车决定是否需要踩刹车。实际的模型可以像弹簧的问题一样是线性的，也可能是一个更为复杂的、基于统计和概率的模型，又或是一个神经网络，旨在模拟人类大脑的工作方式。无论细节如何，几乎每个机器学习系统都在运行该循环。每循环一个周期，系统改善一点点。经过数千甚至数百万次的循环之后，即可以得到比任何人类处理同样任务上表现更好的系统。 机器学习有多种多样的应用，也需要融合各行各业的技术，所以它与许多其他领域相结合。这也是为什么当前机器学习是如此热门的原因。 总结建立一个机器学习系统很复杂，但是理解机器学习的机理却很简单吧。下次遇到开头那样的聚会，不会再云里雾里、一片茫然了吧？你甚至可以抛出自己观点见解，让别人对你刮目相看！]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最常用的20个Linux命令(适用Ubuntu/Centos/MAC/Debian等)]]></title>
    <url>%2F2017%2F12%2F01%2Flinux.html</url>
    <content type="text"><![CDATA[接触过Linux的人都会知道，Linux中的命令的确是非常多，但其中只需要掌握最常用的命令就可以了。相对于Win、Mac、Ubuntu或者其他可视化系统界面，掌握这些命令可以大大提高操作速度。笔者主要是用Linux进行服务器的运维和Python编程，然而每个人用Linux的目的都不同，所以常用的命令也会有差异。在此总结一下，方便一下以后的查阅。 cd命令最基本，也是经常需要使用的命令，它用于切换当前目录，它的参数是要切换到的目录的路径，可以是绝对路径，也可以是相对路径。如：cd /root/Docements # 切换到目录/root/Docements cd ./path # 切换到当前目录下的path目录中，“.”表示当前目录 cd ../path # 切换到上层目录中的path目录中，“..”表示上一层目录 ls命令查看文件与文件夹的命令，list之意，它的参数非常多，下面就列出一些常用的参数吧，如下：-l # 列出长数据串，包含文件的属性与权限数据等 -a # 列出全部的文件，连同隐藏文件（开头为.的文件）一起列出来（常用） -d # 仅列出目录本身，而不是列出目录的文件数据 -h # 将文件容量以较易读的方式（GB，kB等）列出来 -R # 连同子目录的内容一起列出（递归列出），等于该目录下的所有文件都会显示出来 注：这些参数也可以组合使用，下面举两个例子：ls -l # 以长数据串的形式列出当前目录下的数据文件和目录 ls -lR # 以长数据串的形式列出当前目录下的所有文件 mkdir命令makedir之意，即创建一个新的文件夹或子文件夹。常用参数如下：mkdir [-p] DirName # 参数p代表parents，表示递归创建目录。 例如：mkdir newfoldermkdir newfolder/a/b -p 注：如果要创建目录a并创建目录a的子目录b，没有用-p的情况下是mkdir2次如果用-p可以直接创建2个目录mkdir -p目录a子目录b就可以。 grep命令该命令常用于分析一行的信息，若当中有我们所需要的信息，就将该行显示出来，该命令通常与管道命令一起使用，用于对一些命令的输出进行筛选加工等等，它的简单语法为grep [-acinv] [--color=auto] '查找字符串' filename 它的常用参数如下：-a ：将binary文件以text文件的方式查找数据 -c ：计算找到‘查找字符串’的次数 -i ：忽略大小写的区别，即把大小写视为相同 -v ：反向选择，即显示出没有‘查找字符串’内容的那一行 # 例如： # 取出文件/etc/man.config中包含MANPATH的行，并把找到的关键字加上颜色 grep --color=auto 'MANPATH' /etc/man.config # 把ls -l的输出中包含字母file（不区分大小写）的内容输出 ls -l | grep -i file find命令这是一个基于查找的功能非常强大的命令，相对而言，它的使用也相对较为复杂，参数也比较多，所以在这里将给把它们分类列出，它的基本语法如下：find [PATH] [option] [action] # 与时间有关的参数： -mtime n # n为数字，意思为在n天之前的“一天内”被更改过的文件； -mtime +n # 列出在n天之前（不含n天本身）被更改过的文件名； -mtime -n # 列出在n天之内（含n天本身）被更改过的文件名； -newer file # 列出比file还要新的文件名 # 例如： find /root -mtime 0 # 在当前目录下查找今天之内有改动的文件 # 与用户或用户组名有关的参数： -user name # 列出文件所有者为name的文件 -group name # 列出文件所属用户组为name的文件 -uid n # 列出文件所有者为用户ID为n的文件 -gid n # 列出文件所属用户组为用户组ID为n的文件 # 例如： find /home/ljianhui -user ljianhui # 在目录/home/ljianhui中找出所有者为ljianhui的文件 # 与文件权限及名称有关的参数： -name filename # 找出文件名为filename的文件 -size [+-]SIZE # 找出比SIZE还要大（+）或小（-）的文件 -tpye TYPE # 查找文件的类型为TYPE的文件，TYPE的值主要有：一般文件（f)、设备文件（b、c)、目录（d）、连接文件（l）、socket（s）、FIFO管道文件（p）； -perm mode # 查找文件权限刚好等于mode的文件，mode用数字表示，如0755； -perm -mode # 查找文件权限必须要全部包括mode权限的文件，mode用数字表示 -perm +mode # 查找文件权限包含任一mode的权限的文件，mode用数字表示 # 例如： find / -name passwd # 查找文件名为passwd的文件 find . -perm 0755 # 查找当前目录中文件权限的0755的文件 find . -size +12k # 查找当前目录中大于12KB的文件，注意c表示byte cp命令该命令用于复制文件，copy之意，它还可以把多个文件一次性地复制到一个目录下，它的常用参数如下：-a # 将文件的特性一起复制 -p # 连同文件的属性一起复制，而非使用默认方式，与-a相似，常用于备份 -i # 若目标文件已经存在时，在覆盖时会先询问操作的进行 -r # 递归持续复制，用于目录的复制行为 -u # 目标文件与源文件有差异时才会复制 例如 ：cp -a file1 file2 # 连同文件的所有特性把文件file1复制成文件file2cp file1 file2 file3 dir # 把文件file1、file2、file3复制到目录dir中 mv命令该命令用于移动文件、目录或更名，move之意，它的常用参数如下：-f # force强制的意思，如果目标文件已经存在，不会询问而直接覆盖 -i # 若目标文件已经存在，就会询问是否覆盖 -u # 若目标文件已经存在，且比目标文件新，才会更新 注：该命令可以把一个文件或多个文件一次移动一个文件夹中，但是最后一个目标文件一定要是“目录”。 例如：mv file1 file2 file3 dir # 把文件file1、file2、file3移动到目录dir中 mv file1 file2 # 把文件file1重命名为file2 rm命令该命令用于删除文件或目录，remove之意，它的常用参数如下：-f # 就是force的意思，忽略不存在的文件，不会出现警告消息 -i # 互动模式，在删除前会询问用户是否操作 -r # 递归删除，最常用于目录删除，它是一个非常危险的参数 例如：rm -i file # 删除文件file，在删除之前会询问是否进行该操作 rm -fr dir # 强制删除目录dir中的所有文件 ps命令该命令用于将某个时间点的进程运行情况选取下来并输出，process之意，它的常用参数如下：-A # 所有的进程均显示出来 -a # 不与terminal有关的所有进程 -u # 有效用户的相关进程 -x # 一般与a参数一起使用，可列出较完整的信息 -l # 较长，较详细地将PID的信息列出 其实我们只要记住ps一般使用的命令参数搭配即可，它们并不多，如下：ps aux # 查看系统所有的进程数据 ps ax # 查看不与terminal有关的所有进程 ps -lA # 查看系统所有的进程数据 ps axjf # 查看连同一部分进程树状态 kill命令该命令用于向某个工作（%jobnumber）或者是某个PID（数字）传送一个信号，它通常与ps和jobs命令一起使用，它的基本语法如下：kill -signal PID signal的常用参数如下：注：最前面的数字为信号的代号，使用时可以用代号代替相应的信号。1：SIGHUP # 启动被终止的进程 2：SIGINT # 相当于输入ctrl+c，中断一个程序的进行 9：SIGKILL # 强制中断一个进程的进行 15：SIGTERM # 以正常的结束进程方式来终止进程 17：SIGSTOP # 相当于输入ctrl+z，暂停一个进程的进行 例如：# 以正常的结束进程方式来终于第一个后台工作，可用jobs命令查看后台中的第一个工作进程 kill -SIGTERM %1 # 重新改动进程ID为PID的进程，PID可用ps命令通过管道命令加上grep命令进行筛选获得 kill -SIGHUP PID killall命令该命令用于向一个命令启动的进程发送一个信号，它的一般语法如下：killall [-iIe] [command name] 它的参数如下：-i # 交互式的意思，若需要删除时，会询问用户 -e # 表示后面接的command name要一致，但command name不能超过15个字符 -I # 命令名称忽略大小写 # 例如： killall -SIGHUP syslogd # 重新启动syslogd file命令该命令用于判断接在file命令后的文件的基本数据，因为在Linux下文件的类型并不是以后缀为分的，所以这个命令对我们来说就很有用了，它的用法非常简单，基本语法如下：file filename # 例如： file ./test tar命令该命令用于对文件进行打包，默认情况并不会压缩，如果指定了相应的参数，它还会调用相应的压缩程序（如gzip和bzip等）进行压缩和解压。它的常用参数如下：-c # 新建打包文件 -t # 查看打包文件的内容含有哪些文件名 -x # 解打包或解压缩的功能，可以搭配-C（大写）指定解压的目录，注意-c,-t,-x不能同时出现在同一条命令中 -j # 通过bzip2的支持进行压缩/解压缩 -z # 通过gzip的支持进行压缩/解压缩 -v # 在压缩/解压缩过程中，将正在处理的文件名显示出来 -f filename # filename为要处理的文件 -C dir # 指定压缩/解压缩的目录dir 上面的解说可以已经让你晕过去了，但是通常只需要记住下面三条命令即可：压缩：tar -jcv -f filename.tar.bz2 /要被处理的文件或目录名称 查询：tar -jtv -f filename.tar.bz2 解压：tar -jxv -f filename.tar.bz2 -C /欲解压缩的目录 注：文件名并不一定要以后缀tar.bz2结尾，这里主要是为了说明使用的压缩程序为bzip2 cat命令该命令用于查看文本文件的内容，后接要查看的文件名，通常可用管道|与more和less一起使用，从而可以一页页地查看数据。例如：cat text | less # 查看text文件中的内容 # 注：这条命令也可以使用less text来代替 chgrp命令该命令用于改变文件所属用户组，它的使用非常简单，它的基本用法如下：chgrp [-R] dirname/filename -R # 进行递归的持续对所有文件和子目录更改 # 例如： chgrp users -R ./dir # 递归地把dir目录下中的所有文件和子目录下所有文件的用户组修改为users chown命令该命令用于改变文件的所有者，与chgrp命令的使用方法相同，只是修改的文件属性不同，不再详述。 chmod命令该命令用于改变文件的权限，一般的用法如下：chmod [-R] xyz /文件或目录 -R # 进行递归的持续更改，即连同子目录下的所有文件都会更改 同时，chmod还可以使用u（user）、g（group）、o（other）、a（all）和+（加入）、-（删除）、=（设置）跟rwx搭配来对文件的权限进行更改。# 例如： chmod 0755 file # 把file的文件权限改变为-rxwr-xr-x chmod g+w file # 向file的文件权限中加入用户组可写权限 vim命令该命令主要用于文本编辑，它接一个或多个文件名作为参数，如果文件存在就打开，如果文件不存在就以该文件名创建一个文件。vim是一个非常好用的文本编辑器，它里面有很多非常好用的命令，在这里不再多说。你可以参考vim常用操作的详细说明。 time命令该命令用于测算一个命令（即程序）的执行时间。它的使用非常简单，就像平时输入命令一样，不过在命令的前面加入一个time即可，例如：time ./process time ps aux 在程序或命令运行结束后，在最后输出了三个时间，它们分别是： user：用户CPU时间，命令执行完成花费的用户CPU时间，即命令在用户态中执行时间总和； system：系统CPU时间，命令执行完成花费的系统CPU时间，即命令在核心态中执行时间总和； real：实际时间，从command命令行开始执行到运行终止的消逝时间； 注：用户CPU时间和系统CPU时间之和为CPU时间，即命令占用CPU执行的时间总和。实际时间要大于CPU时间，因为Linux是多任务操作系统，往往在执行一条命令时，系统还要处理其它任务。另一个需要注意的问题是即使每次执行相同命令，但所花费的时间也是不一样，其花费时间是与系统运行相关的。 shutdown命令shutdown是最常用也是最安全的关机和重启命令，它会在关机之前调用fsck检查磁盘，其中-h和-r是最常用的参数，另外还有，硬关机：halt、立即关机：poweroff、重启：reboot等。其实这些命令基本上都是调用shutdown，例如：halt # 等同于 shutdown -hreboot # 等同于 shutdown -rpoweroff # 等同于 shutdown -h now-h # 停止系统服务并关机 -r # 停止系统服务后重启 shutdown基本上就下面几个用法：shutdown -h now # 立即关机 shutdown -h 10:53 # 到10:53关机，如果该时间小于当前时间，则到隔天 shutdown -h +10 # 10分钟后自动关机 shutdown -r now # 立即重启 shutdown -r +30 # 30分钟后重启并并发送通知给其它在线用户]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让你的代码变得更简洁、干净]]></title>
    <url>%2F2017%2F11%2F29%2Fcleancode.html</url>
    <content type="text"><![CDATA[你是否见过下面这样的代码？ public String getProductNames(List&lt;Product&gt; products) &#123; StringBuilder strBuf = new StringBuilder(); int i = 0; strBuf.append(products.get(0).name); while (i &lt; products.size()) &#123; strBuf.append(", "); strBuf.append(products.get(i++).name); &#125; return strBuf.toString();&#125; 这样的代码存在于一些保留系统(Legacy System)中，通常很旧。当你看到这样的代码时，很可能感觉不太友好。 这段代码的问题在于：不仅太冗长，更重要的是它隐藏了逻辑（还有一些其他问题，后面讨论）。我们编写代码来解决问题，因此，不应该在代码中创造新的问题。请注意，当编写“系统代码”或者以高性能为目标的库时、或者我们需要解决的问题技术太过复杂时，是可以牺牲可读性。但是即便如此，还是应该尽量避免编写隐藏逻辑且晦涩难懂的代码。 罗伯特·马丁 (Bob大叔)在他的书《Clean Code》中提到 “阅读代码和编写代码的时间比例远远超过10比1”。在一些保留系统中，你要花费大量的时间试图理解如何 阅读代码，而不是实际阅读代码。测试和调试这样的系统也是非常棘手的，大多数情况下，你需要用非常规的方式完全来完成。 代码也在讲故事写代码也是写作的一种。代码不应该隐藏解决问题的逻辑或算法。相反，它应该条理清晰的列出各种函数名称，模块等，甚至代码的格式看起来像已被谨慎和专业地处理过的。 看到下面这段代码有什么感觉？ int calc(int arr[])&#123; int i; int val = 0; for ( i = 0;i&lt;arr.length;i=i +1 ) val = val+1; int j = 0; int sum = 0; while (arr.length&gt;j) &#123;sum += arr[j++] ;&#125; int ret = sum - val; return ret;&#125; 这段代码看起来像战后的战场。看上去碰过这段代码的开发者都很烦它，且尽力回避它，让它处于更糟的状态。凌乱的格式和糟糕的定义清楚地表明，不止一个开发人员掉过坑，听起来像破窗理论对吧？想明白这段代码的功能并不容易（不仅仅是因为你看代码时感觉辣眼睛），这段代码其实返回的是数组的总和减去元素的数量。让我们以更简单的方式来做到这一点： int sumMinusCount(int arr[]) &#123; int sum = IntStream.of(arr).sum(); int count = arr.length; return sum - count;&#125; 现在，用Java 8的Stream，让代码更加简洁并增强可读性。 干净的代码干净的代码不是让代码看起来漂亮，而是使代码更易于维护。当代码太晦涩难懂时，大部分时间浪费在阅读上，导致开发者的生产力降低了，而且使用它的开发人员通常也会让它变得更糟，就像上面讲的那样。原因并不是因为他们无法理清代码，而是由于时间和精力的限制。碰到这样的代码时，很难估计修复bug、植入一个新模块或实现一个新功能需要多长时间，因为原框架和设计隐藏在代码中，不容易发现。因此，为了完成工作，最终会选择草草了事。干净的代码可以表明作者的意图，即便在代码中存在错误，也很容易找到并修复它，也可以长期节省维护时间。 解决（或提高）代码可维护性的方法是花费几个月（或更多）的时间来重构和清理，但是不管企业还是个人通常不太可能接受暂停开发，重构代码。所以，我们能做些什么？ 童子军原则正如Bob大叔所说，“童子军原则”背后的想法其实非常简单：让代码更干净！任何时候你碰到旧的代码，应该先妥善地清理好它。不要只是快捷方式处理，让代码更难理解，而应该认真地对待。这个原则更多地关注开发者应该具有的心态，通过把代码变得更易于维护，让他们的日子过得更舒服。 在大多数情况下处理保留系统是很不容易的，特别是当没有测试或测试套件不再被维护的时候，仍然应该努力使代码更干净。关于如何编写更具表达性的代码，这篇文章更关注一些有用的、一般性的建议。 编写前的思考有个常见的误解：开发的人员开发软件或系统时仅仅是写代码。事实并非如此，相反，我们编写代码来解决问题。代码只是一个媒介，而不是实际的解决方案。随便敲几个键盘是写代码吗？当然不是，因为不可能被电脑编译。同样，没有先考虑如何解决的问题就开始编写代码也不是常规做法。因此，当写代码时，必须三思而后行，以便通过代码提供的解决方案清晰且不模糊。不应该为了写代码而写代码，代码应该解决问题，而不是创建新的问题。 有没有在检查代码时，意识到代码完全错误，唯一的解决办法是从头再写？许多开发人员接到新任务，就立刻开始在IDE中输入内容。他们认为，这样做看起来像在认真工作。大多数情况下，这被证明是错误的方法，因为没有思考就开始写代码会导致错误的方向。当然，不排除一些非常有经验的开发人员可以立刻开始编写，并且仍然朝着正确的方向发展，但是大多数开发者在碰键盘前还是需要仔细计划好。 考虑一下下面这个例子: class Customer &#123; private List&lt;Double&gt; drinks; private BillingStrategy strategy; public Customer(BillingStrategy strategy) &#123; this.drinks = new ArrayList&lt;Double&gt;(); this.strategy = strategy; &#125; public void add(final double price, final int quantity) &#123; drinks.add(strategy.getActPrice(price*quantity)); &#125; // Payment of bill public void printBill() &#123; double sum = 0; for (Double i : drinks) &#123; sum += i; &#125; System.out.println("Total due: " + sum); drinks.clear(); &#125;&#125;interface BillingStrategy &#123; double getActPrice(final double rawPrice);&#125;// Normal billing strategy (unchanged price)class NormalStrategy implements BillingStrategy &#123; @Override public double getActPrice(final double rawPrice) &#123; return rawPrice; &#125;&#125; 上面这段代码来源于维基百科。这个例子中的代码没有什么不好，是吧？其实不然，这段代码使用了Strategy Pattern，表明它需要有一定的灵活性。但在这个例子中，与维基百科不同，只有一个策略实现，且并没有实现更多策略的计划。这里使用Strategy Pattern的意图可能会误导读者，通常实现一个Pattern需要费不少功夫，所以读者自然会想，用这个的原因是什么。YAGNI原则(You aren’t going to need it)，除非你需要它，否则别创建新功能，避免创建你不要的代码。预测未来需要什么是很难的，有时候过往的经验会有帮助，但是在大多数情况下，保持简单还是比较安全的。 使用Pattern帮助我们以一种易于沟通的优雅方式来解决特定的问题。如果本身问题不存在，读者将被误导，反而认为问题确实存在。请注意，并不是反对Pattern，问题是人们总是试图在Pattern解决的问题同时创造新问题，就因为他们知道Pattern这回事。 不要以为代码可以正常编译，就完活了！其实，在代码编写完成的时候，只是完成了一半，要继续工作使代码可以向读者传达我们的意图。 我们的工具集中有很多工具，要在适当的时候使用它们。仅仅因为每个人都在用框架和库就随大流是没有任何意义的。要了解他们到底解决了什么问题，学习以一种不隐匿的方式来使用它们。如何处理框架和库，这里Bob大叔 还有一个很棒的帖子：《Make the Magic go away》。 提高表达性如今，许多编程语言都支持Stream来帮助我们编写表达性代码，例如Java，Kotlin，JavaScript等。Stream已经用if语句取代了冗长的循环，相对于命令式编程，帮助我们用更具声明式编程的方式来考虑数据转换。为了要找到所有小于某个值的元素就反复声明是没有意义的，只需简单地将过滤器应用于Stream。 命令式编程：命令机器如何 去做事情(how)，这样不管你想要的是什么(what)，它都会按照你的命令实现。 声明式编程：告诉机器你想要的是什么(what)，让机器想出如何 去做(how)。 几乎所有支持Stream的语言都有Map, filter 和 reduce。所以，每个人都可以理解你写的东西，就像每个人都能理解一个循环或者一个if语句一样。用这样的表达式来处理数据是非常强大的。首先你就不用测试这个功能。有没有注意到第一个例子中的差一错误 ？这也使我们走向了函数式编程。 第一个例子中的基于Stream 的解决方案如下： public String getProductNames(List&lt;Product&gt; products) &#123; return products.stream() .map(p -&gt; p.name) .collect(Collectors.joining(", "));&#125; 简单又干净，很容易理解它做什么。现在，考虑下面的例子： void getPositiveNumbers(List&lt;Integer&gt; l1, List&lt;Integer&gt; l2) &#123; for (Integer el1: l1) if (el1 &gt; 0) l2.add(el1);&#125; 当你调用这个method时，第二个参数会改变吗？这个method是按照编写的去实现吗？Method的名称是否合适？你真的能“get”吗？ 这样呢？ List&lt;Integer&gt; getPositiveNumbers(List&lt;Integer&gt; numbers) &#123; return numbers.stream() .filter(num -&gt; num &gt; 0) .collect(toList());&#125; 在这个例子中，返回值是一个新的列表，没有参数受到影响。我们只是读取参数并产生一个新的结果，但要理解这个method在做什么以及如何使用它，第二段显然更容易。这种method也可以很容易地与其他method组合，一般而言，组合是Stream和函数式编程的最重要的好处之一。组合能使我们从更高层次的数据转换、过滤等方面进行思考，并编写出更具声明式编程和表达性的代码，让代码表达我们想要实现的(what)而不是如何完成的(how)，这大大改善了代码的可读性。 把一个问题分解成多个子问题，解决每一个子问题，然后组合这些解决方案，为最初的问题提供解决方案，就容易多了。但另一方面，当主要目标是性能时，命令式编程可能又是必不可少的。 请注意，Jave 8中的toList()收集器返回一个可变列表，而在函数式编程中，我们通常使用不可变数据结构。不过，生成新数据并将参数视为只读可以提高method可读性和表现。虽然有些method可能有副作用，但对于一种method来说，要么有副作用（表现为command），要么有返回值（表现为query），不会同时存在。 写更具表达性的代码不是一件容易的事情。爱因斯坦说过：“If you can’t explain it simply, you don’t understand it well enough”。所以，当看到抽象层次代码混合时，例如与数据访问对象(DAO)交互的UI类，或者直接与数据库talk，或者低层次的细节在不应该暴露的时候暴露，可以说不仅违反了单一职责原则，而且还有些混乱。通过使用注释来解决并非最佳解决方案。有人写的越简单、越具表达性，说明他对这个问题的理解就越好。 拥抱不可变对象当对象的状态发生变化，而又没有注意到它的时候，是非常让人困惑的。对构造一半的对象使用return时也是很危险的，特别是处理多线程的程序时。而不可变对象对多线程是安全的，也是完美的缓存对象，因为它们的状态不会改变。 但是为什么选择可变对象呢？最有可能的原因是为了性能表现，因为占用的内存会少一些，因为改变是在原地(in-place)进行的。而且，让一个对象的状态在其整个生命周期中发生变化是很自然的，这是我们在面向对象编程(OOP)中学到的。这些年来，我们一直在写程序，其中大部分的对象都是可变的。 今时不同往日，机器内存的数量、性能比之前翻了N个数量级，真正面临的问题是可扩展性。处理器的速度虽然不再像过去十几年那样猛增了，但现在有了N多核的CPU。所以，需要利用好现在的情况来规划好程序。由于程序需要能够在多个内核上运行，所以要以一种安全的方式来编写。使用可变对象，必须处理好locking以确保其状态的一致性。并发（详解）不是很好处理的。而不可变对象（状态在对象被创建之后就不再变化）在多线程和处理器之间共享是固有安全的，且不需要同步的特性为创建具有低延迟和高吞吐量的系统提供了机会。因此，不可变对象是实现可扩展，更安全的选择。 除了可扩展的好处，不可变对象使我们的代码更简洁、干净了。在上一节的示例中，作为参数传递的集合在调用method后发生了改变。如果是不可变集合，则是不允许的。因此，不可变对象可以促进更好的解决方案。另外，由于状态不变，读者也不需要费心思记，只需要将一个对象名称与一个值关联起来。 程序必须是为人们阅读而写的，只是偶尔地让机器执行。 —— Harold Abelson，《计算机程序的构造和解释》]]></content>
      <tags>
        <tag>干净代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用免费的Google Cloud来部署科学上网神器SS]]></title>
    <url>%2F2017%2F11%2F23%2Fss.html</url>
    <content type="text"><![CDATA[之前一直想搞个搬瓦工或者vultr的VPS来部署SS，实现科(V)学(P)上(N)网，但始终抢不到优惠的实例。偶然间发现Google Cloud在免费，而且貌似免费期从之前的2个月提高到1年，这样看来不用花一分钱，即可实现爱(翻)国(墙)上网，还可以再享受配置、性能更高、更稳定Google服务器，岂不美哉！ Google Cloud免费简介Google Cloud顾名思义即Google提供的云计算服务，和国内的阿里云、腾讯云、百度云类似。提供的服务无非也就那几大类：基础云计算服务、大数据类、物联网、CDN等等。免费以300刀赠金形式，可以体验所有产品当然也包括Compute Engine(即VPS)，需要注意Google的云主机计费方式与国内不同之处在于：国内一般是全包，而Google是云主机、公网IP和流量分开计费，需确保你在一年内的消费不超过300刀，后面会详细讲。 申请与开通VPS主机在一切操作前，你需要先有一个临时的科(V)学(P)上(N)网环境，因为注册和配置Google云服务的工作需要在Google网站上完成。可以在手机里操作，目前有很多相关APP有免费使用时长，半个小时足以。 另外，你需要准备好： 一张Visa或者万事达的信用卡(会扣1美元验证卡真实性，几分钟后就会退还。) 一个美国电话号码(可以用iPlum。非必须，仅仅为提高通过率，目前号码不需要验证，所以非真实号码应该可以。) 一个美国地址(自己去搜索，地址需要真实) 准备就绪： 登陆Google Cloud主页：cloud.google.com，点击TRY IT FREE，登陆你的Google账号。 地区选择美国，然后同意服务条款后，账户类型选择个人，填上地址、信用卡信息，即可开通账户。 开通后创建VM实例，按照下面2张图配置即可，笔者选的是1核1G内存10G硬盘CENTOS6系统，asia-east1-c节点(台湾)。也可根据自己需求选择配置。另外在网络那里选择添加外部静态IP(即公网IP地址)。最后点创建即可开通云主机。 这里说一下配置的选择及价格：主机的价格表不在此列举，自己选择适合的。公网IP基本上是免费，那就来梳理一下流量的计费方式： 流量类型 价格 入口 免费 出口*到同一区域 免费 出口在同一区域内不同的谷歌云平台服务 免费 出口到谷歌产品（如YouTube，Google地图，驱动器） 不收费** 在同一地区区域之间的出口（每GB） $ 0.01 在美国国内地区之间的出口（每GB） $ 0.01 洲际出口 参考下面表格 每月使用 网络(出)全球(不包括中国和澳大利亚，但包括香港)(每GB) 网络(出)中国(不包括香港)(每GB) 网络(出)澳大利亚(每GB) 网络(入) 0-1 TB $ 0.12 $ 0.23 $ 0.19 免费 1-10 TB $ 0.11 $ 0.22 $ 0.18 免费 10+ TB $为0.08 $ 0.20 $ 0.15 免费 可以看出如果每月流量不超过1TB，就是$0.23月/GB。以最低配主机(如果仅仅用于科学上网，最低配没问题)为例，$5/月，一年是$60，还剩下$240用于流量的开销，240 / 0.23 = 1043GB， 1043 / 12个月 = 86GB 也就是每个月用 86GB流量，足够了。当然也可以选择更高配置的主机，这样流量少一点，自己权衡。 配置防火墙开通主机后，因为后面要配置SS，默认的防火墙限制太多，需要修改防火墙规则。在控制台/VPC网络/防火墙规则里，名称随便写，其他按下图配置即可。IP地址范围： 0.0.0.0/0 配置SSH 用 PuTTYgen生成密钥使用SSH工具Xshell或者Putty，这里以Putty为例，使用方法参考之前文章，Putty安装好后程序包里有一个PuttyGen工具，打开后，直接点击Generate来生成一对密钥用于登陆SSH。注意： 生成好后在key comment处，原本生成的应该是rsa-key-20171123，需要修改成rsa-key-20170905XXXX，XXXX是你申请Google Cloud 时，“XXXX@gmail.com” 前的字符，说白了就是你邮箱的用户名。完成后将 public key 保存，保存为.pub格式文件，然后保存 private key，保存为.ppk文件格式！ Google Cloud控制台 导入公钥在控制台/compute engine/元数据中，右边点击SSH密钥，点击修改，添加刚刚保存的公钥.pub文件里的内容进去保存即可。 Putty里导入私钥 连接实例打开Putty ，在Connection/SSH/Auth, 导入刚刚保存的私钥.ppk文件。如下图。接下来回到session，在Host Name (or IP address)中填入步骤1修改过的 Key comment ＋@实例 ip(比如rsa-key-20170905name@8.8.8.8)，即可登录SSH。 连接成功后，输入sudo -i即可获得root权限。 SS的安装与配置先来说说SS特点 ： 省电（在电量查看里几乎看不到它的身影） 支持开机自启动，且断网无影响，无需手动重连 可使用自己的服务器（安全和速度的保证） 支持区分国内外流量（PAC模式） 可对应用设置单独代理 安装和配置主要是参考秋水逸冰文章： 在VPS上安装SS前，需要先安装最新内核并开启 BBR，可以使用秋水逸冰的一键安装脚本，具体看这里。BBR 即拥塞控制算法，目的是要尽量跑满带宽, 并且尽量不要有排队的情况, 效果并不比速锐差。据很多人反馈，速度比锐速还厉害！！ SS的安装和配置具体也可见秋水逸冰一键安装脚本。一般选择Python版。 最后在Win、Mac、IOS、android中下载对应的SS客户端，填入以上配置好的IP、端口、密码，选择相应的加密方式(Win下，右键任务栏纸飞机小图标，启用系统代理)，即可去探索外面的世界了。]]></content>
      <tags>
        <tag>VPS</tag>
        <tag>SS</tag>
        <tag>科学上网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Valine插件为Hexo博客添加评论功能]]></title>
    <url>%2F2017%2F11%2F21%2Fvaline.html</url>
    <content type="text"><![CDATA[Hexo由于其静态特性，具有一定的局限性，因此需要借助于第三方服务来扩展站点的功能。作为一个博客系统，Hexo几乎完美，唯独(默认模式下)差了一个最重要的互动功能——访客评论。NexT主题内置了多款第三方评论系统：多说、畅言、有言、disqus、gitment等等，试用过后都觉得差强人意。不经意间发现了Valine，部署简单，界面风格简洁，调用迅速(无后端)，还支持Markdown，这简直就是Hexo的绝配。 至于放弃其他几个系统，主要原因有以下： 多说 - 这个不必多说，已经关闭； 畅言 - 搜狐旗下，应该不错，不过域名需要备案才可以使用，是一个不小的门槛； 有言 - jiaThis旗下，使用过程中遇到多次无法在页面中正常加载的情况，不稳定； disqus和gitment - 一句话，远在大洋彼岸不适合国内使用。 Valine简介 Valine(官网)是一款基于Leancloud的快速、简洁且高效的无后端评论系统。 特性 快速 安全 无后端实现 MarkDown 全语法支持 轻量易用(~15kb gzipped) Valine配置及使用获取appid和appkey请先登录或注册 LeanCloud, 进入控制台后点击左下角创建应用，选择免费的开发版即可。注意右上角有几个节点，可以就近选择。应用创建好以后，进入刚刚创建的应用，选择左下角的设置&gt;应用Key，然后就能看到你的appid和appkey了：为了数据安全，请注意设置自己的安全域名： Hexo-NexT中的开启和设置Hexo-NexT中已经默认安装了Valine插件，如果没有可以使用以下命令安装： npm install valine --save 完成后，在NexT主题配置文件中加入/修改代码以开启： # Valine.# You can get your appid and appkey from https://leancloud.cn# more info please open https://valine.js.orgvaline: enable: true # 是否开启 appid: # 填上之前获取的AppID appkey: # 填上之前获取的AppKey notify: false # 新留言是否需要通知 https://github.com/xCss/Valine/wiki verify: false # 是否需要验证，验证比较反人类建议false关闭 placeholder: 请在此输入您的留言 # 默认留言框内的文字 avatar: mm # 默认头像 guest_info: nick,mail # 默认留言框的头部需要访问者输入的信息 pageSize: 10 # pagination size #默认单页的留言条数 OK，至此已经已经完成配置并成功开启，Hexo g -d赶紧去看效果吧。 后期如果需要管理留言，至leancloud/控制台/储存/comment即可进行添加、删除等操作。]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>Valine</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用又拍云CDN加速Hexo博客]]></title>
    <url>%2F2017%2F11%2F21%2Fcdn.html</url>
    <content type="text"><![CDATA[辛辛苦苦搭建好博客，虽然Hexo本身是全静态网页，页面加载速度相对于动态博客程序已经是非常可观，但NexT主题调用了不少js文件，如果再加上其他的图片、音视频插件等等还是会在一定程度上造成延迟。本着折腾不止和完美主义的精神，用CDN来加速Hexo！ CDN加速的原理这里简明扼要地解释一下CDN加速的原理：你上传到CDN加速网站(如又拍或者七牛)空间里的文件(或者网站)以镜像的形式存放到多台服务器，这些服务器分布在祖国甚至全世界各地，访问者就近读取较快的镜像，以实现快速加载的效果。举个栗子：你的文件(或网站)在上海，没有CDN，一个北京的访问者需要直接连接你在上海的服务器，有了CDN，这个北京的访问者只需要访问你的文件(网站)在北京的镜像即可。尤其是国内外的互访，CDN可使访问速度大大提升。 哪些因素会影响加载速度？js文件js文件就是JavaScript脚本文件，用来实现各种酷炫的动态效果。一般是加载在html页面的&lt;head&gt;部分，所以页面加载速度首先要考虑这一块。Hexo的js文件大致包含以下3类： 公共js公共js是通用型，比如实现图片放大效果的Fancybox，或者实现图片慢加载的LazyLoad等等。这些js已经开发好，直接在html里引用(存放在镜像网站上，如BootCDN)js文件链接即可实现效果。 定制页面效果js即NexT主题中定制的某些特效，例如实现页面响应式效果的Bootstrap，或者增强移动端滚动及动画效果的Motion等等。这些js理论上也是公共js，只不过NexT主题作者修改了代码，以适用于NexT主题。这些js文件存放在本地Hexo目录hexo\themes\next\source\js\src下。 第三方插件js这个不用多说了吧，Hexo默认安装了不少实用的第三方插件，比如，可直接在网页中显示数学公式的MathJax，优化SEO的Baidu-push等等。这些插件可在主题配置文件_config.yml中进行配置。相关js文件有些存放在hexo\themes\next\layout\_third-party中，有些则通过外部引用形式加载。图片(音、视频)如果博客文章很多，绝大部分的带宽都会消耗在这部分静态数据上。这个不多说了。Google字体引用很多文章中提到，由于被墙的缘故，引用Google字体会严重拖累网站，于是乎屏蔽Google字体的插件层出不穷。不过笔者测试发现，无论是Google字体中文官网，还是Google字体的引用服务器fonts.googleapis.com都没有被墙，而其速度在全球范围内都相当理想(如下图)，所以完全没有必要修改Google字体的引用源，比如改成360CDN什么的。 综上，下面就开始着手对Hexo博客的js文件和图片(音、视频)文件进行CDN加速。 CDN加速公共js加速在版本 5.0.1 之后的NexT主题，有一个方便的功能可以通过修改主题配置文件_config.yml中常用外部js的引用地址，来实现自定义CDN加速。下面是此部分的配置(在_config.yml搜索CDN即可找到)，笔者已经修改成BootCDN的引用地址。关于国内靠谱的JavaScript CDN库，还是推荐BootCDN，可参考知乎的讨论。 # Script Vendors.# Set a CDN address for the vendor you want to customize.# For example# jquery: https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js# Be aware that you should use the same version as internal ones to avoid potential problems.# Please use the https protocol of CDN files when you enable https on your site.vendors: # Internal path prefix. Please do not edit it. _internal: lib # Internal version: 2.1.3 jquery: https://cdn.bootcss.com/jquery/2.1.3/jquery.min.js # Internal version: 2.1.5 # See: http://fancyapps.com/fancybox/ fancybox: https://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js fancybox_css: https://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css # Internal version: 1.0.6 # See: https://github.com/ftlabs/fastclick fastclick: https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js # Internal version: 1.9.7 # See: https://github.com/tuupola/jquery_lazyload lazyload: https://cdn.bootcss.com/jquery_lazyload/1.9.7/jquery.lazyload.min.js # Internal version: 1.2.1 # See: http://VelocityJS.org velocity: https://cdn.bootcss.com/velocity/1.2.1/velocity.min.js # Internal version: 1.2.1 # See: http://VelocityJS.org velocity_ui: https://cdn.bootcss.com/velocity/1.2.1/velocity.ui.min.js # Internal version: 0.7.9 # See: https://faisalman.github.io/ua-parser-js/ ua_parser: https://cdn.bootcss.com/UAParser.js/0.7.9/ua-parser.min.js # Internal version: 4.6.2 # See: http://fontawesome.io/ fontawesome: https://cdn.bootcss.com/font-awesome/4.6.2/css/font-awesome.min.css # Internal version: 1 # https://www.algolia.com algolia_instant_js: algolia_instant_css: # Internal version: 1.0.2 # See: https://github.com/HubSpot/pace # Or use direct links below: # pace: //cdn.bootcss.com/pace/1.0.2/pace.min.js # pace_css: //cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-flash.min.css pace: https://cdn.bootcss.com/pace/1.0.2/pace.js pace_css: https://cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-flash.min.css 使用Chrome浏览器开发者工具-&gt;Network，按住Shift+刷新(全新加载)即可看到效果。下图显示加速的效果非常好！修改前首页加载需要10秒以上，其中尤其index.js(即JQuery.js)严重拖累了加载速度。修改之后，基本上就是——秒开！ 页面效果js加速这些js文件存放在本地，原则上把它们上传到CDN加速空间中，再修改引用源即可。但基于以下原因考虑，这里不做修改。 这些js文件对加载速度影响不大； 如果主题更新又会恢复到原始状态； 修改引用源改动源文件较多、比较麻烦。 插件js加速同样道理，这些js文件若是存放在Hexo本地的，需要将他们上传到CDN加速空间里；如果是外部引用，需要先将引用地址的原js文件下载下来，存放到CDN加速空间里。最后统一修改原引用地址到CDN加速空间地址。 下面以又拍云的CDN为例介绍，注册开通很简单，这里略过。需要注意不管七牛还是又拍，注册时都需要上传手持身份证的照片进行身份核验。身份认证后即可开始操作，具体操作方法请参考官方文档。简单说两句：创建的服务选择网页图片类型，然后添加操作员、密码即可，后面如有需要还可以绑定域名(需备案)，https等等。 一切就绪后，下面以加速valine.js插件为例说明。Valine是一款评论插件，安装及配置请参考《使用Valine插件为Hexo博客添加评论功能》。 开启并配置好Valine后，打开hexo\themes\next\layout\_third-party\comments\valine.js可以看到如下代码： &lt;script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"&gt;&lt;/script&gt;&lt;script src='//unpkg.com/valine/dist/Valine.min.js'&gt;&lt;/script&gt; 可以看出Valine的运行是依赖以上2个外部js文件，这里以加速第二个js文件为例，修改第二个js文件的源为： &lt;script src="//XXX.test.upcdn.net/Valine.min.js"&gt;&lt;/script&gt; # XXX改成你的又拍云服务名 然后，把原js文件Valine.min.js、即https://unpkg.com/valine/dist/Valine.min.js下载下来，通过FTP工具(推荐FileZilla)上传到你的又拍云空间根目录里。 这样，Valine.min.js这个文件就在用又拍云进行CDN加速了。Hexo g -d查看效果吧。其他插件js的加速理论上适用上述方法，关键是第一步要找到js文件正真的源引用地址。 图片(音、视频)加速其实如果以上的操作没有问题，图片(音、视频)的CDN加速也是同样的方法。 比如，你的文章里有本来有一张图片，图片地址为http://xxx.com/123.jpg。把这个图片上传到你的又拍云空间里，即可获得地址：http://xxx.test.upcdn.net/123.jpg，将此地址插入到文章中即可实现图片的CDN加速。而且后期还可以利用又拍云的云处理功能对图片增加缩略图、水印、防盗链，对音视频转解码，压缩等等。 如果你理解以上的原理，可以将其他任何类型(一般加速图片，音频，视频，js，css等)的静态文件的转移到CDN上，从而将你的网站优化的更好。]]></content>
      <tags>
        <tag>CDN</tag>
        <tag>Hexo</tag>
        <tag>又拍云</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在阿里云VPS上部署Hexo]]></title>
    <url>%2F2017%2F11%2F16%2Fhexo.html</url>
    <content type="text"><![CDATA[自双11购入了阿里云的VPS后，一直想着捯饬些什么，首当其冲的就是搭一个博客站点。之前使用过WordPress、Joomla、Drupal、国人的Typecho、Emlog、Zblog等。前几个国外的博客虽然功能、插件、模版丰富，但感觉略显臃肿，过多冗余之处，不适合做个人站点使用，尤其不适合笔者的1G1M的小水管主机。而国人的Typecho、Emlog感觉不错，安装使用简单、占用内存少、界面清新，没有多余的功能，支持Markdown，还原写作本质。但在使用中，出现不少小问题，细节不完善，影响实际体验，遂弃之。直到遇见了Hexo…… Hexo的介绍不再赘述，可以登录其中文官网了解。其实在接触Hexo之前，笔者就对纯静态的博客框架有所了解，比如jekyll、octopress等。与Hexo一样，他们的共同的优点就是部署页面纯静态html，加载速度快、浏览体验好、占用内存小，支持Markdown，当然最重要的一点是有逼格。最终放弃Jekyll等等选择Hexo的原因是：相对于Jekyll基于Ruby实现，Hexo基于Node.js，在Windows上安装Node.js环境更简单，另外，Hexo的主题更符合我的品位。 这类静态博客系统最大的一个缺陷就在于要求用户具有一定的技术水平，Hexo是我见过最难建立的博客系统。网上有很多文章是把Hexo部署到Github或者Coding等，优点是搭建快捷、免费，缺点显而易见，Github远在大洋彼岸，加载速度可想而知，而Coding则是有广告。既然已经有了云主机，当然不能浪费。笔者阅读了网上N多文章及教程，踩过坑，走过弯路，在经历N次的失败后，终于搭建成功。下面就把最简明扼要的过程列出来，谨以此自勉或造福后人。 准备条件VPS及域名笔者购买的是阿里云的轻量云服务器，1核1G1M20GSSD，CentOS 7.4系统，搭配宝塔面板(方便可视化操作)，本文操作过程理论上适用于其他Linux系统。域名需添加A解析记录指向主机IP，域名购买、解析(国内VPS需备案)的过程请自行搜索。 SSH工具SSH工具是我们用来以命令行的方式远程操作服务器端。Putty小巧、免费，Xshell功能更强大，但是收费。笔者使用的是Putty，点此下载(最新版)，注意本地操作系统，自行下载相应版本安装。如何使用SSH工具连接VPS，请看阿里云的官方教程。 本地端配置本地配置很简单，依次安装好Node.js和Git,再安装Hexo即可，Hexo需要前两者的支持。本人是用的win10系统，本地端不需要什么配置，只要安装相应版本即可，Mac或Linux系统应该更容易。 安装Node.js这里给出Node.js官方下载链接：https://nodejs.org/zh-cn/download/安装没什么好说的，一路默认下一步即可。 安装Git同样给出Git官方下载链接：https://git-scm.com/downloads对应自己的本地系统下载即可，这个套件不仅仅在windows上安装了Git版本控制系统，最重要的是这个套件提供了Git Bash，一个可以在windows上运行的Linux风格shell，除非你够硬核，能忍受win的cmd，否则通过Git Bash使用hexo无疑是最佳选择。下图的选项建议勾选，视觉效果有明显提升。其余选项保持默认即可。 安装并熟悉HexoHexo最好的教程当然是官方文档！先不用花时间全看完官方文档，这里稍微说下要点，部署好之后可以仔细研究官方文档。 首先是安装，在Git Bash下输入这条命令就安装Hexo了，简单吧。不过这仅仅是把Hexo的程序写进了系统，网站还没有部署好。 npm install -g hexo-cli 注意：npm在国内被墙了，国内用户需要挂代理，否则输入命令后半天没反应。这里推荐一个最好的办法。每次要用npm命令时，先输入以下命令行。 npm config set registry https://registry.npm.taobao.org 接下来熟悉怎么使用Hexo 首先建立一个站点 hexo init &lt;folder&gt; //以folder为目录名建立站点文件夹cd &lt;folder&gt; //转移到站点目录npm install //安装依赖 一个网站对应着一个站点文件夹，这里就是你的整个Hexo博客网站。之后的操作我们都在该站点目录下进行。 以上，也可以先新建一个文件夹，直接右键Git Bash Here。然后hexo init即可。 新建一篇文章 hexo new &lt;title&gt; 新建立的文章是markdown（以下简称md）文件，熟悉mac的一定知道吧，不熟悉的几分钟就能上手。我们编辑博客就是用编辑md文件实现的。在source/_post目录下，我们看到里面已经有个hello-world.md了。 编辑文章就是编辑你新建的md文件啦。这就需要markdown编辑器喽，当然mac就省事了，对于win系统，Typora和MarkdownPad编辑器，看个人喜好选择。 启动本地服务器 hexo s 这条命令会在本地启动服务器，访问地址为localhost:4000，主要是我们正式发布前预览测试用的，启动后你编辑文章和主题等都可以直接更新到该网址，非常方便！但是注意，编辑站点配置文件_config.yml是需要重启该服务器才生效的。现在我们就看下自带hello-world.md的预览效果吧。还是蛮酷炫的吧！ 这里有个坑吐槽一下，若Win安装了福某PDF阅读器会占用4000端口，需要用hexo s -p 5000命令把端口换成5000来执行启动。 生成静态文件 hexo g 这条命令是由各种md文件和资源生成可部署的静态html页面等，生成的资源都放在新生成的public目录下。 部署到服务器 hexo d 部署方式有多种，对这篇文章来说，就是利用Git部署到你的VPS服务器了，当然在这输入是没卵用的~还没配置服务器端。 掌握以上命令基本就OK了，还有一条hexo clean用来清理缓存，其他的一般用不到，有兴趣的再看官方文档。接下来我们看VPS服务器端配置。 VPS服务器端配置这一部分的配置就用之前说的Xshell或putty来搞定！ 创建用户创建用户用于服务器端站点管理，如下： adduser hexo //创建用户passwd hexo //设置密码su //检查是否有安装sudo 有的linux系统初始没安装sudo，为了方便，我们需要安装sudo，已有安装的话，跳过这步。 yum install sudo 再次，为了方便，赋予hexo用户root权限，使用vi命令在/etc/sudoers中添加一行。不会vim编辑临时搜一下，简单，当然也可以通过宝塔面板进行可视化操作。 vi /etc/sudoers 找到这一行添加： root ALL=(ALL) ALLhexo ALL=(ALL) ALL #这个是添加的 配置本地端无密码ssh登录服务端这里为什么要用到Git呢？因为这里的Hexo发布博客是用Git来部署的，而Git又是基于ssh连接的，所以实现一键发布博客就得配置这玩意了。其实很简单，有的教程复杂化了，注意这里最后一步是在本地端操作。 服务器端生成ssh密钥 su hexocd /home/hexomkdir .sshcd .sshssh-keygen -t rsa 在生成密钥时，会要求你输入一个加密密码，可以不填写(一路回车)，实现无密码登陆。完成后会在/home/hexo/.ssh/文件夹下生成2个key，一个公钥id_rsa.pub，一个私钥id_rsa，编辑此文件夹中的authorized_keys文件(如没有则新建一个)，把公钥里面的内容全部复制粘贴进去(包含公钥开头的ssh-rsa)。然后把公钥和私钥2个文件下载到本地，后面会用到。 服务器端确保配置及权限正确(这一步仅为确保，可暂时忽略，若后面ssh连接不成功可返回此步骤检查) 查看/etc/ssh/sshd_config文件配置是否如下： HostKey /etc/ssh/ssh_host_rsa_keyRSAAuthentication yes PubkeyAuthentication yesAuthorizedKeysFile .ssh/authorized_keys 确保用户hexo及.ssh文件夹及相关密钥文件权限正确 chown -R hexo:hexo /home/hexochmod 700 /home/hexochmod 700 /home/hexo/.sshchmod 644 /home/hexo/.ssh/authorized_keys //公钥文件的所有权限chmod 600 /home/hexo/.ssh/id_rsa //私钥文件的所有权限 查看是否有安装ssh并安装，没有的话使用yum安装 rpm -qa |grep ssh //检查是否有sshyum install ssh //如果没有ssh运行，则执行此命令安装ssh 安装完后启动服务 service sshd startservice sshd status //检查是否已启动，看到running即可 本地端ssh配置 打开Git Bash，输入pwd查看本地用户的文件夹地址，如下图，一般默认在C:\User\你的账户名。然后打开用户文件夹里的.ssh文件夹，把刚刚从服务器上下载到本地的两个密钥文件拷贝进去。 本地端ssh验证 ssh hexo@你的域名或者IP //@前是你创建的站点管理用户 OK，无密码ssh登陆完成，配置过程注意是在本地端还是服务器端操作。如果连接不成功，返回上述第2步检查。 安装配置nginx简单来说，nginx是代理服务器，有它我们就能按照域名或IP访问网页了。 添加nginx源，安装nginx在/etc/yum.repos.d目录下创建一个yum源文件nginx.repo,用vi编辑或用宝塔写入如下内容。 [nginx]name=nginx repobaseurl=http://nginx.org/packages/centos/$releasever/$basearch/gpgcheck=0enabled=1 安装nginx(宝塔里面也有一键安装nginx，不过这种方式更简单) yum install nginx -ynginx -v //查看版本号验证 删除原配置文件 rm /etc/nginx/conf.d/* 重新配置，添加以下内容到/etc/nginx/conf.d/hexo.conf server &#123; root /home/hexo/www; #网站根目录,用来存储网站文件，后面会创建 index index.html index.htm; server_name www.shup.cn; #你的域名 location / &#123; try_files $uri $uri/ /index.html; &#125;&#125; 看到没，这一步将你的域名和服务器下的网站根目录挂钩，主页是根目录下index.html很关键！！ 修改nginx配置文件将/etc/nginx/nginx.conf中第一行的user值修改为hexo 切换到hexo用户，用户主目录下新建www文件夹作为网站根目录 su hexocd ~mkdir www 验证配置是否正确，如下图。 启动nginx服务并测试 sudo service nginx startecho "hello nginx" &gt; /home/hexo/www/index.html //站点根目录下新建index.html 在浏览器中输入你的域名或VPS的IP地址，出现hello nginx字样表示nginx代理服务器搭建成功！ 安装配置Git即将完成任务~ 安装Git sudo yum install git 初始化Git仓库用户主目录下新建hexo.git文件夹用作Git仓库并初始化 cd ~mkdir hexo.gitcd hexo.gitgit init --bare //初始化git仓库，bare表示空仓库 配置Git仓库的hooks hooks，钩子，就是将不同目录的数据实现同步。具体如下，在Git仓库hooks目录下创建文件post-receive并修改权限 cd hookstouch post-receivechmod 755 post-receive 将以下内容添加到post-receive中 #!/bin/bashGIT_REPO=/home/hexo/hexo.gitTMP_GIT_CLONE=/tmp/HexoBlogPUBLIC_WWW=/home/hexo/wwwrm -rf $&#123;TMP_GIT_CLONE&#125;git clone $GIT_REPO $TMP_GIT_CLONErm -rf $&#123;PUBLIC_WWW&#125;/*cp -rf $&#123;TMP_GIT_CLONE&#125;/* $&#123;PUBLIC_WWW&#125; 至此，服务器端的配置全部完成。 本地端部署验证接下来我们就试试把博客发布到VPS服务器吧！下面都是本地端的操作。 安装hexo git部署模块国内用户别忘记挂代理。 npm install hexo-deployer-git --save 修改站点配置文件_config.yml# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://www.shup.cn #这里修改你的网址或者IProot: / 部署项配置： deploy: type: git #部署方式 repo: hexo@www.shup.cn:/home/hexo/hexo.git #@符号之前是服务器的管理用户，之后是服务器的git仓库路径 branch: master #分支，我们只用主分支即可 部署验证hexo clean //清除缓存（实际是删除db.json和public文件夹）hexo g //生成静态页面（public文件夹）hexo d //部署到服务器 OK，完结撒花，浏览器输入你的域名看看吧！ 其实就是最初给你预览的helloworld，只不过它搬到服务器了！ 以后我们发布博客就用我讲解Hexo那一章的第2-6步就可以了，甚至可以用hexo g -d来一键生成发布！这样你就可以专心写md了，发布只是一个命令的事！]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>VPS</tag>
      </tags>
  </entry>
</search>
